Index: configure
===================================================================
--- configure	(revision 34728)
+++ configure	(working copy)
@@ -564,6 +564,7 @@
   --with-install=PATH    path to a custom install program
 
 Advanced options:
+  --flavor=system           build a specified target system
   --enable-mmx              enable MMX [autodetect]
   --enable-mmxext           enable MMX2 (Pentium III, Athlon) [autodetect]
   --enable-3dnow            enable 3DNow! [autodetect]
@@ -616,6 +617,7 @@
 # GOTCHA: the variables below defines the default behavior for autodetection
 # and have - unless stated otherwise - at least 2 states : yes no
 # If autodetection is available then the third state is: auto
+_flavor=none
 _mmx=auto
 _3dnow=auto
 _3dnowext=auto
@@ -1004,6 +1006,9 @@
   --disable-debug)
     _debug=
     ;;
+  --flavor=*)
+    _flavor=`echo $ac_option | cut -d '=' -f 2`
+    ;;
   --enable-runtime-cpudetection)    _runtime_cpudetection=yes   ;;
   --disable-runtime-cpudetection)   _runtime_cpudetection=no    ;;
   --enable-cross-compile)           _cross_compile=yes          ;;
@@ -2567,6 +2572,72 @@
   test -n "$cflags_stackrealign" && echores "yes" || echores "no"
 fi # if darwin && test "$cc_vendor" = "gnu" ; then
 
+# user selected target system
+if test "$_runtime_cpudetection" = no ; then
+    case "$host_arch-$cc_vendor-$_flavor" in
+        *-none) ;; # No flavor, standard build
+        i386-gnu-pentium4|i386-gnu-p4)
+         _mmx=yes
+         _mmxext=yes
+         _3dnow=auto
+         _3dnowext=auto
+         test $_sse = "auto" && _sse=yes
+         test $_sse2 = "auto" && _sse2=yes
+         _mcpu=$cpuopt=pentium4
+         _march=-march=pentium4
+         ;;
+        i386-gnu-pentium3|i386-gnu-p3)
+         ## Not tested
+         _mmx=yes
+         _mmxext=yes
+         _3dnow=auto
+         _3dnowext=auto
+         test $_sse = "auto" && _sse=yes
+         _sse2=auto
+         _mcpu=$cpuopt=pentium3
+         _march=-march=pentium3
+         ;;
+        i386-gnu-athlon)
+         _mmx=yes
+         _mmxext=yes
+         _3dnow=yes
+         _3dnowext=yes
+         _sse=auto
+         _sse2=auto
+         _mcpu=$cpuopt=athlon
+         _march=-march=athlon
+         ;;
+        i386-gnu-athlon-xp)
+         _mmx=yes
+         _mmxext=yes
+         _3dnow=yes
+         _3dnowext=yes
+         test $_sse = "auto" && _sse=yes
+         _sse2=auto
+         _mcpu=$cpuopt=athlon-xp
+         _march=-march=athlon-xp
+         ;;
+        i386-gnu-k8)
+         _mmx=yes
+         _mmxext=yes
+         _3dnow=yes
+         _3dnowext=yes
+         test $_sse = "auto" && _sse=yes
+         test $_sse2 = "auto" && _sse2=yes
+         _mcpu=$cpuopt=k8
+         _march=-march=k8
+         ;;
+        *)
+         echo "Invalid/unsupported target system $host_arch-$cc_vendor-$_flavor"
+         exit 1
+         ;;
+    esac
+    if test "$_flavor" != none ; then
+        # move this to case if adding different cpu
+        iproc=686
+        _optimizing="Custom Target $_flavor"
+    fi
+fi
 
 # Checking for CFLAGS
 _install_strip="-s"
@@ -3470,10 +3541,17 @@
 if test "$_memalign" = yes ; then
   def_memalign='#define HAVE_MEMALIGN 1'
 else
+  if mingw32 ; then
+    _memalign=yes
+    def_memalign='#define HAVE_MEMALIGN 1'
+    def_map_memalign='extern void *memalign(unsigned int boundary, unsigned int size);'
+    res_comment="emulated"
+  else
   def_memalign='#define HAVE_MEMALIGN 0'
   def_map_memalign='#define memalign(a, b) malloc(b)'
   darwin || def_memalign_hack='#define CONFIG_MEMALIGN_HACK 1'
 fi
+fi
 echores "$_memalign"
 
 
@@ -7671,6 +7749,10 @@
 done
 libs_mplayer=$ld_tmp
 
+if mingw32 ; then
+ libs_mplayer="$libs_mplayer osdep/alloc-win.c"
+ libs_mencoder="$libs_mencoder osdep/alloc-win.c"
+fi
 
 #############################################################################
 
Index: libao2/ao_sdl.c
===================================================================
--- libao2/ao_sdl.c	(revision 34728)
+++ libao2/ao_sdl.c	(working copy)
@@ -142,7 +142,7 @@
 	mp_msg(MSGT_AO,MSGL_INFO,MSGTR_AO_SDL_INFO, rate, (channels > 1) ? "Stereo" : "Mono", af_fmt2str_short(format));
 
 	if(ao_subdevice) {
-		setenv("SDL_AUDIODRIVER", ao_subdevice, 1);
+		putenv("SDL_AUDIODRIVER=1");
 		mp_msg(MSGT_AO,MSGL_INFO,MSGTR_AO_SDL_DriverInfo, ao_subdevice);
 	}
 
Index: libass/ass.c
===================================================================
--- libass/ass.c	(revision 34728)
+++ libass/ass.c	(working copy)
@@ -28,7 +28,6 @@
 #include <sys/stat.h>
 #include <unistd.h>
 #include <inttypes.h>
-#include <ctype.h>
 
 #ifdef CONFIG_ICONV
 #include <iconv.h>
@@ -70,7 +69,6 @@
     }
     free(track->style_format);
     free(track->event_format);
-    free(track->Language);
     if (track->styles) {
         for (i = 0; i < track->n_styles; ++i)
             ass_free_style(track, i);
@@ -597,12 +595,6 @@
         track->ScaledBorderAndShadow = parse_bool(str + 22);
     } else if (!strncmp(str, "Kerning:", 8)) {
         track->Kerning = parse_bool(str + 8);
-    } else if (!strncmp(str, "Language:", 9)) {
-        char *p = str + 9;
-        while (*p && isspace(*p)) p++;
-        track->Language = malloc(3);
-        strncpy(track->Language, p, 2);
-        track->Language[2] = 0;
     }
     return 0;
 }
@@ -1277,36 +1269,3 @@
     track->parser_priv = calloc(1, sizeof(ASS_ParserPriv));
     return track;
 }
-
-/**
- * \brief Prepare track for rendering
- */
-void ass_lazy_track_init(ASS_Library *lib, ASS_Track *track)
-{
-    if (track->PlayResX && track->PlayResY)
-        return;
-    if (!track->PlayResX && !track->PlayResY) {
-        ass_msg(lib, MSGL_WARN,
-               "Neither PlayResX nor PlayResY defined. Assuming 384x288");
-        track->PlayResX = 384;
-        track->PlayResY = 288;
-    } else {
-        if (!track->PlayResY && track->PlayResX == 1280) {
-            track->PlayResY = 1024;
-            ass_msg(lib, MSGL_WARN,
-                   "PlayResY undefined, setting to %d", track->PlayResY);
-        } else if (!track->PlayResY) {
-            track->PlayResY = track->PlayResX * 3 / 4;
-            ass_msg(lib, MSGL_WARN,
-                   "PlayResY undefined, setting to %d", track->PlayResY);
-        } else if (!track->PlayResX && track->PlayResY == 1024) {
-            track->PlayResX = 1280;
-            ass_msg(lib, MSGL_WARN,
-                   "PlayResX undefined, setting to %d", track->PlayResX);
-        } else if (!track->PlayResX) {
-            track->PlayResX = track->PlayResY * 4 / 3;
-            ass_msg(lib, MSGL_WARN,
-                   "PlayResX undefined, setting to %d", track->PlayResX);
-        }
-    }
-}
Index: libass/ass.h
===================================================================
--- libass/ass.h	(revision 34728)
+++ libass/ass.h	(working copy)
@@ -23,7 +23,7 @@
 #include <stdarg.h>
 #include "ass_types.h"
 
-#define LIBASS_VERSION 0x01000000
+#define LIBASS_VERSION 0x00913000
 
 /*
  * A linked list of images produced by an ass renderer.
@@ -61,19 +61,6 @@
 } ASS_Hinting;
 
 /**
- * \brief Text shaping levels.
- *
- * SIMPLE is a fast, font-agnostic shaper that can do only substitutions.
- * COMPLEX is a slower shaper using OpenType for substitutions and positioning.
- *
- * libass uses the best shaper available by default.
- */
-typedef enum {
-    ASS_SHAPING_SIMPLE = 0,
-    ASS_SHAPING_COMPLEX
-} ASS_ShapingLevel;
-
-/**
  * \brief Initialize the library.
  * \return library handle or NULL if failed
  */
@@ -160,13 +147,6 @@
 void ass_set_frame_size(ASS_Renderer *priv, int w, int h);
 
 /**
- * \brief Set shaping level. This is merely a hint, the renderer will use
- * whatever is available if the request cannot be fulfilled.
- * \param level shaping level
- */
-void ass_set_shaper(ASS_Renderer *priv, ASS_ShapingLevel level);
-
-/**
  * \brief Set frame margins.  These values may be negative if pan-and-scan
  * is used.
  * \param priv renderer handle
Index: libass/ass_bitmap.c
===================================================================
--- libass/ass_bitmap.c	(revision 34728)
+++ libass/ass_bitmap.c	(working copy)
@@ -1,6 +1,5 @@
 /*
  * Copyright (C) 2006 Evgeniy Stepanov <eugeni.stepanov@gmail.com>
- * Copyright (C) 2011 Grigori Goronzy <greg@chown.ath.cx>
  *
  * This file is part of libass.
  *
@@ -23,7 +22,6 @@
 #include <assert.h>
 #include <ft2build.h>
 #include FT_GLYPH_H
-#include FT_OUTLINE_H
 
 #include "ass_utils.h"
 #include "ass_bitmap.h"
@@ -135,12 +133,10 @@
 static Bitmap *alloc_bitmap(int w, int h)
 {
     Bitmap *bm;
-    unsigned s = w; // XXX: alignment
     bm = malloc(sizeof(Bitmap));
-    bm->buffer = calloc(s, h);
+    bm->buffer = calloc(w, h);
     bm->w = w;
     bm->h = h;
-    bm->stride = s;
     bm->left = bm->top = 0;
     return bm;
 }
@@ -157,57 +153,70 @@
     Bitmap *dst = alloc_bitmap(src->w, src->h);
     dst->left = src->left;
     dst->top = src->top;
-    memcpy(dst->buffer, src->buffer, src->stride * src->h);
+    memcpy(dst->buffer, src->buffer, src->w * src->h);
     return dst;
 }
 
-Bitmap *outline_to_bitmap(ASS_Library *library, FT_Library ftlib,
-                          FT_Outline *outline, int bord)
+int check_glyph_area(ASS_Library *library, FT_Glyph glyph)
 {
+    FT_BBox bbox;
+    long long dx, dy;
+    FT_Glyph_Get_CBox(glyph, FT_GLYPH_BBOX_TRUNCATE, &bbox);
+    dx = bbox.xMax - bbox.xMin;
+    dy = bbox.yMax - bbox.yMin;
+    if (dx * dy > 8000000) {
+        ass_msg(library, MSGL_WARN, "Glyph bounding box too large: %dx%dpx",
+               (int) dx, (int) dy);
+        return 1;
+    } else
+        return 0;
+}
+
+static Bitmap *glyph_to_bitmap_internal(ASS_Library *library,
+                                          FT_Glyph glyph, int bord)
+{
+    FT_BitmapGlyph bg;
+    FT_Bitmap *bit;
     Bitmap *bm;
     int w, h;
+    unsigned char *src;
+    unsigned char *dst;
+    int i;
     int error;
-    FT_BBox bbox;
-    FT_Bitmap bitmap;
 
-    FT_Outline_Get_CBox(outline, &bbox);
-    // move glyph to origin (0, 0)
-    bbox.xMin &= ~63;
-    bbox.yMin &= ~63;
-    FT_Outline_Translate(outline, -bbox.xMin, -bbox.yMin);
-    // bitmap size
-    bbox.xMax = (bbox.xMax + 63) & ~63;
-    bbox.yMax = (bbox.yMax + 63) & ~63;
-    w = (bbox.xMax - bbox.xMin) >> 6;
-    h = (bbox.yMax - bbox.yMin) >> 6;
-    // pen offset
-    bbox.xMin >>= 6;
-    bbox.yMax >>= 6;
+    if (check_glyph_area(library, glyph))
+        return 0;
+    error = FT_Glyph_To_Bitmap(&glyph, FT_RENDER_MODE_NORMAL, 0, 0);
+    if (error) {
+        ass_msg(library, MSGL_WARN, "FT_Glyph_To_Bitmap error %d",
+               error);
+        return 0;
+    }
 
-    if (w * h > 8000000) {
-        ass_msg(library, MSGL_WARN, "Glyph bounding box too large: %dx%dpx",
-                w, h);
-        return NULL;
+    bg = (FT_BitmapGlyph) glyph;
+    bit = &(bg->bitmap);
+    if (bit->pixel_mode != FT_PIXEL_MODE_GRAY) {
+        ass_msg(library, MSGL_WARN, "Unsupported pixel mode: %d",
+               (int) (bit->pixel_mode));
+        FT_Done_Glyph(glyph);
+        return 0;
     }
 
-    // allocate and set up bitmap
+    w = bit->width;
+    h = bit->rows;
     bm = alloc_bitmap(w + 2 * bord, h + 2 * bord);
-    bm->left = bbox.xMin - bord;
-    bm->top = -bbox.yMax - bord;
-    bitmap.width = w;
-    bitmap.rows = h;
-    bitmap.pitch = bm->stride;
-    bitmap.buffer = bm->buffer + bord + bm->stride * bord;
-    bitmap.num_grays = 256;
-    bitmap.pixel_mode = FT_PIXEL_MODE_GRAY;
+    bm->left = bg->left - bord;
+    bm->top = -bg->top - bord;
 
-    // render into target bitmap
-    if ((error = FT_Outline_Get_Bitmap(ftlib, outline, &bitmap))) {
-        ass_msg(library, MSGL_WARN, "Failed to rasterize glyph: %d\n", error);
-        ass_free_bitmap(bm);
-        return NULL;
+    src = bit->buffer;
+    dst = bm->buffer + bord + bm->w * bord;
+    for (i = 0; i < h; ++i) {
+        memcpy(dst, src, w);
+        src += bit->pitch;
+        dst += bm->w;
     }
 
+    FT_Done_Glyph(glyph);
     return bm;
 }
 
@@ -223,16 +232,16 @@
     const int l = bm_o->left > bm_g->left ? bm_o->left : bm_g->left;
     const int t = bm_o->top > bm_g->top ? bm_o->top : bm_g->top;
     const int r =
-        bm_o->left + bm_o->stride <
-        bm_g->left + bm_g->stride ? bm_o->left + bm_o->stride : bm_g->left + bm_g->stride;
+        bm_o->left + bm_o->w <
+        bm_g->left + bm_g->w ? bm_o->left + bm_o->w : bm_g->left + bm_g->w;
     const int b =
         bm_o->top + bm_o->h <
         bm_g->top + bm_g->h ? bm_o->top + bm_o->h : bm_g->top + bm_g->h;
 
     unsigned char *g =
-        bm_g->buffer + (t - bm_g->top) * bm_g->stride + (l - bm_g->left);
+        bm_g->buffer + (t - bm_g->top) * bm_g->w + (l - bm_g->left);
     unsigned char *o =
-        bm_o->buffer + (t - bm_o->top) * bm_o->stride + (l - bm_o->left);
+        bm_o->buffer + (t - bm_o->top) * bm_o->w + (l - bm_o->left);
 
     for (y = 0; y < b - t; ++y) {
         for (x = 0; x < r - l; ++x) {
@@ -241,8 +250,8 @@
             c_o = o[x];
             o[x] = (c_o > c_g) ? c_o - (c_g / 2) : 0;
         }
-        g += bm_g->stride;
-        o += bm_o->stride;
+        g += bm_g->w;
+        o += bm_o->w;
     }
 }
 
@@ -250,30 +259,27 @@
  * \brief Shift a bitmap by the fraction of a pixel in x and y direction
  * expressed in 26.6 fixed point
  */
-static void shift_bitmap(Bitmap *bm, int shift_x, int shift_y)
+static void shift_bitmap(unsigned char *buf, int w, int h, int shift_x,
+                         int shift_y)
 {
     int x, y, b;
-    int w = bm->w;
-    int h = bm->h;
-    int s = bm->stride;
-    unsigned char *buf = bm->buffer;
 
     // Shift in x direction
     if (shift_x > 0) {
         for (y = 0; y < h; y++) {
             for (x = w - 1; x > 0; x--) {
-                b = (buf[x + y * s - 1] * shift_x) >> 6;
-                buf[x + y * s - 1] -= b;
-                buf[x + y * s] += b;
+                b = (buf[x + y * w - 1] * shift_x) >> 6;
+                buf[x + y * w - 1] -= b;
+                buf[x + y * w] += b;
             }
         }
     } else if (shift_x < 0) {
         shift_x = -shift_x;
         for (y = 0; y < h; y++) {
             for (x = 0; x < w - 1; x++) {
-                b = (buf[x + y * s + 1] * shift_x) >> 6;
-                buf[x + y * s + 1] -= b;
-                buf[x + y * s] += b;
+                b = (buf[x + y * w + 1] * shift_x) >> 6;
+                buf[x + y * w + 1] -= b;
+                buf[x + y * w] += b;
             }
         }
     }
@@ -282,18 +288,18 @@
     if (shift_y > 0) {
         for (x = 0; x < w; x++) {
             for (y = h - 1; y > 0; y--) {
-                b = (buf[x + (y - 1) * s] * shift_y) >> 6;
-                buf[x + (y - 1) * s] -= b;
-                buf[x + y * s] += b;
+                b = (buf[x + (y - 1) * w] * shift_y) >> 6;
+                buf[x + (y - 1) * w] -= b;
+                buf[x + y * w] += b;
             }
         }
     } else if (shift_y < 0) {
         shift_y = -shift_y;
         for (x = 0; x < w; x++) {
             for (y = 0; y < h - 1; y++) {
-                b = (buf[x + (y + 1) * s] * shift_y) >> 6;
-                buf[x + (y + 1) * s] -= b;
-                buf[x + y * s] += b;
+                b = (buf[x + (y + 1) * w] * shift_y) >> 6;
+                buf[x + (y + 1) * w] -= b;
+                buf[x + y * w] += b;
             }
         }
     }
@@ -424,20 +430,16 @@
  * \brief Blur with [[1,2,1]. [2,4,2], [1,2,1]] kernel
  * This blur is the same as the one employed by vsfilter.
  */
-static void be_blur(Bitmap *bm)
+static void be_blur(unsigned char *buf, int w, int h)
 {
-    int w = bm->w;
-    int h = bm->h;
-    int s = bm->stride;
-    unsigned char *buf = bm->buffer;
     unsigned int x, y;
     unsigned int old_sum, new_sum;
 
     for (y = 0; y < h; y++) {
-        old_sum = 2 * buf[y * s];
+        old_sum = 2 * buf[y * w];
         for (x = 0; x < w - 1; x++) {
-            new_sum = buf[y * s + x] + buf[y * s + x + 1];
-            buf[y * s + x] = (old_sum + new_sum) >> 2;
+            new_sum = buf[y * w + x] + buf[y * w + x + 1];
+            buf[y * w + x] = (old_sum + new_sum) >> 2;
             old_sum = new_sum;
         }
     }
@@ -445,18 +447,18 @@
     for (x = 0; x < w; x++) {
         old_sum = 2 * buf[x];
         for (y = 0; y < h - 1; y++) {
-            new_sum = buf[y * s + x] + buf[(y + 1) * s + x];
-            buf[y * s + x] = (old_sum + new_sum) >> 2;
+            new_sum = buf[y * w + x] + buf[(y + 1) * w + x];
+            buf[y * w + x] = (old_sum + new_sum) >> 2;
             old_sum = new_sum;
         }
     }
 }
 
-int outline_to_bitmap3(ASS_Library *library, ASS_SynthPriv *priv_blur,
-                       FT_Library ftlib, FT_Outline *outline, FT_Outline *border,
-                       Bitmap **bm_g, Bitmap **bm_o, Bitmap **bm_s,
-                       int be, double blur_radius, FT_Vector shadow_offset,
-                       int border_style)
+int glyph_to_bitmap(ASS_Library *library, ASS_SynthPriv *priv_blur,
+                    FT_Glyph glyph, FT_Glyph outline_glyph,
+                    Bitmap **bm_g, Bitmap **bm_o, Bitmap **bm_s,
+                    int be, double blur_radius, FT_Vector shadow_offset,
+                    int border_style)
 {
     blur_radius *= 2;
     int bbord = be > 0 ? sqrt(2 * be) : 0;
@@ -469,13 +471,13 @@
 
     *bm_g = *bm_o = *bm_s = 0;
 
-    if (outline)
-        *bm_g = outline_to_bitmap(library, ftlib, outline, bord);
+    if (glyph)
+        *bm_g = glyph_to_bitmap_internal(library, glyph, bord);
     if (!*bm_g)
         return 1;
 
-    if (border) {
-        *bm_o = outline_to_bitmap(library, ftlib, border, bord);
+    if (outline_glyph) {
+        *bm_o = glyph_to_bitmap_internal(library, outline_glyph, bord);
         if (!*bm_o) {
             return 1;
         }
@@ -484,9 +486,9 @@
     // Apply box blur (multiple passes, if requested)
     while (be--) {
         if (*bm_o)
-            be_blur(*bm_o);
+            be_blur((*bm_o)->buffer, (*bm_o)->w, (*bm_o)->h);
         else
-            be_blur(*bm_g);
+            be_blur((*bm_g)->buffer, (*bm_g)->w, (*bm_g)->h);
     }
 
     // Apply gaussian blur
@@ -498,12 +500,12 @@
         generate_tables(priv_blur, blur_radius);
         if (*bm_o)
             ass_gauss_blur((*bm_o)->buffer, priv_blur->tmp,
-                           (*bm_o)->w, (*bm_o)->h, (*bm_o)->stride,
+                           (*bm_o)->w, (*bm_o)->h, (*bm_o)->w,
                            (int *) priv_blur->gt2, priv_blur->g_r,
                            priv_blur->g_w);
         else
             ass_gauss_blur((*bm_g)->buffer, priv_blur->tmp,
-                           (*bm_g)->w, (*bm_g)->h, (*bm_g)->stride,
+                           (*bm_g)->w, (*bm_g)->h, (*bm_g)->w,
                            (int *) priv_blur->gt2, priv_blur->g_r,
                            priv_blur->g_w);
     }
@@ -519,7 +521,8 @@
 
     assert(bm_s);
 
-    shift_bitmap(*bm_s, shadow_offset.x, shadow_offset.y);
+    shift_bitmap((*bm_s)->buffer, (*bm_s)->w,(*bm_s)->h,
+                 shadow_offset.x, shadow_offset.y);
 
     return 0;
 }
Index: libass/ass_bitmap.h
===================================================================
--- libass/ass_bitmap.h	(revision 34728)
+++ libass/ass_bitmap.h	(working copy)
@@ -32,12 +32,9 @@
 typedef struct {
     int left, top;
     int w, h;                   // width, height
-    int stride;
     unsigned char *buffer;      // w x h buffer
 } Bitmap;
 
-Bitmap *outline_to_bitmap(ASS_Library *library, FT_Library ftlib,
-                          FT_Outline *outline, int bord);
 /**
  * \brief perform glyph rendering
  * \param glyph original glyph
@@ -47,12 +44,13 @@
  * \param bm_g out: pointer to the bitmap of glyph shadow is returned here
  * \param be 1 = produces blurred bitmaps, 0 = normal bitmaps
  */
-int outline_to_bitmap3(ASS_Library *library, ASS_SynthPriv *priv_blur,
-                       FT_Library ftlib, FT_Outline *outline, FT_Outline *border,
-                       Bitmap **bm_g, Bitmap **bm_o, Bitmap **bm_s,
-                       int be, double blur_radius, FT_Vector shadow_offset,
-                       int border_style);
+int glyph_to_bitmap(ASS_Library *library, ASS_SynthPriv *priv_blur,
+                    FT_Glyph glyph, FT_Glyph outline_glyph,
+                    Bitmap **bm_g, Bitmap **bm_o, Bitmap **bm_s,
+                    int be, double blur_radius, FT_Vector shadow_offset,
+                    int border_style);
 
 void ass_free_bitmap(Bitmap *bm);
+int check_glyph_area(ASS_Library *library, FT_Glyph glyph);
 
 #endif                          /* LIBASS_BITMAP_H */
Index: libass/ass_cache.c
===================================================================
--- libass/ass_cache.c	(revision 34728)
+++ libass/ass_cache.c	(working copy)
@@ -1,6 +1,5 @@
 /*
  * Copyright (C) 2006 Evgeniy Stepanov <eugeni.stepanov@gmail.com>
- * Copyright (C) 2011 Grigori Goronzy <greg@chown.ath.cx>
  *
  * This file is part of libass.
  *
@@ -21,35 +20,129 @@
 
 #include <inttypes.h>
 #include <ft2build.h>
-#include FT_OUTLINE_H
+#include FT_FREETYPE_H
+#include FT_GLYPH_H
+
 #include <assert.h>
 
 #include "ass_utils.h"
+#include "ass.h"
+#include "ass_fontconfig.h"
 #include "ass_font.h"
+#include "ass_bitmap.h"
 #include "ass_cache.h"
 
-// type-specific functions
-// create hash/compare functions for bitmap, outline and composite cache
-#define CREATE_HASH_FUNCTIONS
-#include "ass_cache_template.h"
-#define CREATE_COMPARISON_FUNCTIONS
-#include "ass_cache_template.h"
+static unsigned hashmap_hash(void *buf, size_t len)
+{
+    return fnv_32a_buf(buf, len, FNV1_32A_INIT);
+}
 
+static int hashmap_key_compare(void *a, void *b, size_t size)
+{
+    return memcmp(a, b, size) == 0;
+}
+
+static void hashmap_item_dtor(void *key, size_t key_size, void *value,
+                              size_t value_size)
+{
+    free(key);
+    free(value);
+}
+
+Hashmap *hashmap_init(ASS_Library *library, size_t key_size,
+                      size_t value_size, int nbuckets,
+                      HashmapItemDtor item_dtor,
+                      HashmapKeyCompare key_compare,
+                      HashmapHash hash)
+{
+    Hashmap *map = calloc(1, sizeof(Hashmap));
+    map->library = library;
+    map->nbuckets = nbuckets;
+    map->key_size = key_size;
+    map->value_size = value_size;
+    map->root = calloc(nbuckets, sizeof(hashmap_item_p));
+    map->item_dtor = item_dtor ? item_dtor : hashmap_item_dtor;
+    map->key_compare = key_compare ? key_compare : hashmap_key_compare;
+    map->hash = hash ? hash : hashmap_hash;
+    return map;
+}
+
+void hashmap_done(Hashmap *map)
+{
+    int i;
+    // print stats
+    if (map->count > 0 || map->hit_count + map->miss_count > 0)
+        ass_msg(map->library, MSGL_V,
+               "cache statistics: \n  total accesses: %d\n  hits: %d\n  "
+               "misses: %d\n  object count: %d",
+               map->hit_count + map->miss_count, map->hit_count,
+               map->miss_count, map->count);
+
+    for (i = 0; i < map->nbuckets; ++i) {
+        HashmapItem *item = map->root[i];
+        while (item) {
+            HashmapItem *next = item->next;
+            map->item_dtor(item->key, map->key_size, item->value,
+                           map->value_size);
+            free(item);
+            item = next;
+        }
+    }
+    free(map->root);
+    free(map);
+}
+
+// does nothing if key already exists
+void *hashmap_insert(Hashmap *map, void *key, void *value)
+{
+    unsigned hash = map->hash(key, map->key_size);
+    HashmapItem **next = map->root + (hash % map->nbuckets);
+    while (*next) {
+        if (map->key_compare(key, (*next)->key, map->key_size))
+            return (*next)->value;
+        next = &((*next)->next);
+        assert(next);
+    }
+    (*next) = malloc(sizeof(HashmapItem));
+    (*next)->key = malloc(map->key_size);
+    (*next)->value = malloc(map->value_size);
+    memcpy((*next)->key, key, map->key_size);
+    memcpy((*next)->value, value, map->value_size);
+    (*next)->next = 0;
+
+    map->count++;
+    return (*next)->value;
+}
+
+void *hashmap_find(Hashmap *map, void *key)
+{
+    unsigned hash = map->hash(key, map->key_size);
+    HashmapItem *item = map->root[hash % map->nbuckets];
+    while (item) {
+        if (map->key_compare(key, item->key, map->key_size)) {
+            map->hit_count++;
+            return item->value;
+        }
+        item = item->next;
+    }
+    map->miss_count++;
+    return 0;
+}
+
+//---------------------------------
 // font cache
-static unsigned font_hash(void *buf, size_t len)
+
+static unsigned font_desc_hash(void *buf, size_t len)
 {
     ASS_FontDesc *desc = buf;
     unsigned hval;
     hval = fnv_32a_str(desc->family, FNV1_32A_INIT);
     hval = fnv_32a_buf(&desc->bold, sizeof(desc->bold), hval);
     hval = fnv_32a_buf(&desc->italic, sizeof(desc->italic), hval);
-    hval = fnv_32a_buf(&desc->treat_family_as_pattern,
-            sizeof(desc->treat_family_as_pattern), hval);
-    hval = fnv_32a_buf(&desc->vertical, sizeof(desc->vertical), hval);
     return hval;
 }
 
-static unsigned font_compare(void *key1, void *key2, size_t key_size)
+static int font_compare(void *key1, void *key2, size_t key_size)
 {
     ASS_FontDesc *a = key1;
     ASS_FontDesc *b = key2;
@@ -66,287 +159,227 @@
     return 1;
 }
 
-static void font_destruct(void *key, void *value)
+static void font_hash_dtor(void *key, size_t key_size, void *value,
+                           size_t value_size)
 {
     ass_font_free(value);
     free(key);
 }
 
+ASS_Font *ass_font_cache_find(Hashmap *font_cache,
+                              ASS_FontDesc *desc)
+{
+    return hashmap_find(font_cache, desc);
+}
+
+/**
+ * \brief Add a face struct to cache.
+ * \param font font struct
+*/
+void *ass_font_cache_add(Hashmap *font_cache, ASS_Font *font)
+{
+    return hashmap_insert(font_cache, &(font->desc), font);
+}
+
+Hashmap *ass_font_cache_init(ASS_Library *library)
+{
+    Hashmap *font_cache;
+    font_cache = hashmap_init(library, sizeof(ASS_FontDesc),
+                              sizeof(ASS_Font),
+                              1000,
+                              font_hash_dtor, font_compare, font_desc_hash);
+    return font_cache;
+}
+
+void ass_font_cache_done(Hashmap *font_cache)
+{
+    hashmap_done(font_cache);
+}
+
+
+// Create hash/compare functions for bitmap and glyph
+#define CREATE_HASH_FUNCTIONS
+#include "ass_cache_template.h"
+#define CREATE_COMPARISON_FUNCTIONS
+#include "ass_cache_template.h"
+
+//---------------------------------
 // bitmap cache
-static void bitmap_destruct(void *key, void *value)
+
+static void bitmap_hash_dtor(void *key, size_t key_size, void *value,
+                             size_t value_size)
 {
     BitmapHashValue *v = value;
-    BitmapHashKey *k = key;
     if (v->bm)
         ass_free_bitmap(v->bm);
     if (v->bm_o)
         ass_free_bitmap(v->bm_o);
     if (v->bm_s)
         ass_free_bitmap(v->bm_s);
-    if (k->type == BITMAP_CLIP)
-        free(k->u.clip.text);
     free(key);
     free(value);
 }
 
-static size_t bitmap_size(void *value, size_t value_size)
+void *cache_add_bitmap(Hashmap *bitmap_cache, BitmapHashKey *key,
+                       BitmapHashValue *val)
 {
-    BitmapHashValue *val = value;
+    // Note: this is only an approximation
     if (val->bm_o)
-        return val->bm_o->w * val->bm_o->h * 3;
+        bitmap_cache->cache_size += val->bm_o->w * val->bm_o->h * 3;
     else if (val->bm)
-        return val->bm->w * val->bm->h * 3;
-    return 0;
+        bitmap_cache->cache_size += val->bm->w * val->bm->h * 3;
+
+    return hashmap_insert(bitmap_cache, key, val);
 }
 
-static unsigned bitmap_hash(void *key, size_t key_size)
+/**
+ * \brief Get a bitmap from bitmap cache.
+ * \param key hash key
+ * \return requested hash val or 0 if not found
+*/
+BitmapHashValue *cache_find_bitmap(Hashmap *bitmap_cache,
+                                   BitmapHashKey *key)
 {
-    BitmapHashKey *k = key;
-    switch (k->type) {
-        case BITMAP_OUTLINE: return outline_bitmap_hash(&k->u, key_size);
-        case BITMAP_CLIP: return clip_bitmap_hash(&k->u, key_size);
-        default: return 0;
-    }
+    return hashmap_find(bitmap_cache, key);
 }
 
-static unsigned bitmap_compare (void *a, void *b, size_t key_size)
+Hashmap *ass_bitmap_cache_init(ASS_Library *library)
 {
-    BitmapHashKey *ak = a;
-    BitmapHashKey *bk = b;
-    if (ak->type != bk->type) return 0;
-    switch (ak->type) {
-        case BITMAP_OUTLINE: return outline_bitmap_compare(&ak->u, &bk->u, key_size);
-        case BITMAP_CLIP: return clip_bitmap_compare(&ak->u, &bk->u, key_size);
-        default: return 0;
-    }
+    Hashmap *bitmap_cache;
+    bitmap_cache = hashmap_init(library,
+                                sizeof(BitmapHashKey),
+                                sizeof(BitmapHashValue),
+                                0xFFFF + 13,
+                                bitmap_hash_dtor, bitmap_compare,
+                                bitmap_hash);
+    return bitmap_cache;
 }
 
-// composite cache
-static void composite_destruct(void *key, void *value)
+void ass_bitmap_cache_done(Hashmap *bitmap_cache)
 {
-    CompositeHashValue *v = value;
-    free(v->a);
-    free(v->b);
-    free(key);
-    free(value);
+    hashmap_done(bitmap_cache);
 }
 
-// outline cache
-
-static unsigned outline_hash(void *key, size_t key_size)
+Hashmap *ass_bitmap_cache_reset(Hashmap *bitmap_cache)
 {
-    OutlineHashKey *k = key;
-    switch (k->type) {
-        case OUTLINE_GLYPH: return glyph_hash(&k->u, key_size);
-        case OUTLINE_DRAWING: return drawing_hash(&k->u, key_size);
-        default: return 0;
-    }
-}
+    ASS_Library *lib = bitmap_cache->library;
 
-static unsigned outline_compare(void *a, void *b, size_t key_size)
-{
-    OutlineHashKey *ak = a;
-    OutlineHashKey *bk = b;
-    if (ak->type != bk->type) return 0;
-    switch (ak->type) {
-        case OUTLINE_GLYPH: return glyph_compare(&ak->u, &bk->u, key_size);
-        case OUTLINE_DRAWING: return drawing_compare(&ak->u, &bk->u, key_size);
-        default: return 0;
-    }
+    ass_bitmap_cache_done(bitmap_cache);
+    return ass_bitmap_cache_init(lib);
 }
 
-static void outline_destruct(void *key, void *value)
+//---------------------------------
+// glyph cache
+
+static void glyph_hash_dtor(void *key, size_t key_size, void *value,
+                            size_t value_size)
 {
-    OutlineHashValue *v = value;
-    OutlineHashKey *k = key;
-    if (v->outline)
-        outline_free(v->lib, v->outline);
-    if (v->border)
-        outline_free(v->lib, v->border);
-    if (k->type == OUTLINE_DRAWING)
-        free(k->u.drawing.text);
+    GlyphHashValue *v = value;
+    if (v->glyph)
+        FT_Done_Glyph(v->glyph);
+    if (v->outline_glyph)
+        FT_Done_Glyph(v->outline_glyph);
     free(key);
     free(value);
 }
 
+void *cache_add_glyph(Hashmap *glyph_cache, GlyphHashKey *key,
+                      GlyphHashValue *val)
+{
+	if (val->glyph && val->glyph->format == FT_GLYPH_FORMAT_BITMAP) {
+		FT_Bitmap *bitmap = &((FT_BitmapGlyph) val->glyph)->bitmap;
+		glyph_cache->cache_size += bitmap->rows * bitmap->pitch;
+	}
 
-
-// Cache data
-typedef struct cache_item {
-    void *key;
-    void *value;
-    struct cache_item *next;
-} CacheItem;
-
-struct cache {
-    unsigned buckets;
-    CacheItem **map;
-
-    HashFunction hash_func;
-    ItemSize size_func;
-    HashCompare compare_func;
-    CacheItemDestructor destruct_func;
-    size_t key_size;
-    size_t value_size;
-
-    size_t cache_size;
-    unsigned hits;
-    unsigned misses;
-    unsigned items;
-};
-
-// Hash for a simple (single value or array) type
-static unsigned hash_simple(void *key, size_t key_size)
-{
-    return fnv_32a_buf(key, key_size, FNV1_32A_INIT);
+    return hashmap_insert(glyph_cache, key, val);
 }
 
-// Comparison of a simple type
-static unsigned compare_simple(void *a, void *b, size_t key_size)
+/**
+ * \brief Get a glyph from glyph cache.
+ * \param key hash key
+ * \return requested hash val or 0 if not found
+*/
+GlyphHashValue *cache_find_glyph(Hashmap *glyph_cache,
+                                 GlyphHashKey *key)
 {
-    return memcmp(a, b, key_size) == 0;
+    return hashmap_find(glyph_cache, key);
 }
 
-// Default destructor
-static void destruct_simple(void *key, void *value)
+Hashmap *ass_glyph_cache_init(ASS_Library *library)
 {
-    free(key);
-    free(value);
+    Hashmap *glyph_cache;
+    glyph_cache = hashmap_init(library, sizeof(GlyphHashKey),
+                               sizeof(GlyphHashValue),
+                               0xFFFF + 13,
+                               glyph_hash_dtor, glyph_compare, glyph_hash);
+    return glyph_cache;
 }
 
-
-// Create a cache with type-specific hash/compare/destruct/size functions
-Cache *ass_cache_create(HashFunction hash_func, HashCompare compare_func,
-                        CacheItemDestructor destruct_func, ItemSize size_func,
-                        size_t key_size, size_t value_size)
+void ass_glyph_cache_done(Hashmap *glyph_cache)
 {
-    Cache *cache = calloc(1, sizeof(*cache));
-    cache->buckets = 0xFFFF;
-    cache->hash_func = hash_simple;
-    cache->compare_func = compare_simple;
-    cache->destruct_func = destruct_simple;
-    cache->size_func = size_func;
-    if (hash_func)
-        cache->hash_func = hash_func;
-    if (compare_func)
-        cache->compare_func = compare_func;
-    if (destruct_func)
-        cache->destruct_func = destruct_func;
-    cache->key_size = key_size;
-    cache->value_size = value_size;
-    cache->map = calloc(cache->buckets, sizeof(CacheItem *));
-
-    return cache;
+    hashmap_done(glyph_cache);
 }
 
-void *ass_cache_put(Cache *cache, void *key, void *value)
+Hashmap *ass_glyph_cache_reset(Hashmap *glyph_cache)
 {
-    unsigned bucket = cache->hash_func(key, cache->key_size) % cache->buckets;
-    CacheItem **item = &cache->map[bucket];
-    while (*item)
-        item = &(*item)->next;
-    (*item) = calloc(1, sizeof(CacheItem));
-    (*item)->key = malloc(cache->key_size);
-    (*item)->value = malloc(cache->value_size);
-    memcpy((*item)->key, key, cache->key_size);
-    memcpy((*item)->value, value, cache->value_size);
+    ASS_Library *lib = glyph_cache->library;
 
-    cache->items++;
-    if (cache->size_func)
-        cache->cache_size += cache->size_func(value, cache->value_size);
-    else
-        cache->cache_size++;
-
-    return (*item)->value;
+    ass_glyph_cache_done(glyph_cache);
+    return ass_glyph_cache_init(lib);
 }
 
-void *ass_cache_get(Cache *cache, void *key)
-{
-    unsigned bucket = cache->hash_func(key, cache->key_size) % cache->buckets;
-    CacheItem *item = cache->map[bucket];
-    while (item) {
-        if (cache->compare_func(key, item->key, cache->key_size)) {
-            cache->hits++;
-            return item->value;
-        }
-        item = item->next;
-    }
-    cache->misses++;
-    return NULL;
-}
 
-int ass_cache_empty(Cache *cache, size_t max_size)
-{
-    int i;
+//---------------------------------
+// composite cache
 
-    if (cache->cache_size < max_size)
-        return 0;
-
-    for (i = 0; i < cache->buckets; i++) {
-        CacheItem *item = cache->map[i];
-        while (item) {
-            CacheItem *next = item->next;
-            cache->destruct_func(item->key, item->value);
-            free(item);
-            item = next;
-        }
-        cache->map[i] = NULL;
-    }
-
-    cache->items = cache->hits = cache->misses = cache->cache_size = 0;
-
-    return 1;
-}
-
-void ass_cache_stats(Cache *cache, size_t *size, unsigned *hits,
-                     unsigned *misses, unsigned *count)
+static void composite_hash_dtor(void *key, size_t key_size, void *value,
+                                size_t value_size)
 {
-    if (size)
-        *size = cache->cache_size;
-    if (hits)
-        *hits = cache->hits;
-    if (misses)
-        *misses = cache->misses;
-    if (count)
-        *count = cache->items;
+    CompositeHashValue *v = value;
+    free(v->a);
+    free(v->b);
+    free(key);
+    free(value);
 }
 
-void ass_cache_done(Cache *cache)
+void *cache_add_composite(Hashmap *composite_cache,
+                          CompositeHashKey *key,
+                          CompositeHashValue *val)
 {
-    ass_cache_empty(cache, 0);
-    free(cache->map);
-    free(cache);
+    return hashmap_insert(composite_cache, key, val);
 }
 
-// Type-specific creation function
-Cache *ass_font_cache_create(void)
+/**
+ * \brief Get a composite bitmap from composite cache.
+ * \param key hash key
+ * \return requested hash val or 0 if not found
+*/
+CompositeHashValue *cache_find_composite(Hashmap *composite_cache,
+                                         CompositeHashKey *key)
 {
-    return ass_cache_create(font_hash, font_compare, font_destruct,
-            (ItemSize)NULL, sizeof(ASS_FontDesc), sizeof(ASS_Font));
+    return hashmap_find(composite_cache, key);
 }
 
-Cache *ass_outline_cache_create(void)
+Hashmap *ass_composite_cache_init(ASS_Library *library)
 {
-    return ass_cache_create(outline_hash, outline_compare, outline_destruct,
-            NULL, sizeof(OutlineHashKey), sizeof(OutlineHashValue));
+    Hashmap *composite_cache;
+    composite_cache = hashmap_init(library, sizeof(CompositeHashKey),
+                                   sizeof(CompositeHashValue),
+                                   0xFFFF + 13,
+                                   composite_hash_dtor, composite_compare,
+                                   composite_hash);
+    return composite_cache;
 }
 
-Cache *ass_glyph_metrics_cache_create(void)
+void ass_composite_cache_done(Hashmap *composite_cache)
 {
-    return ass_cache_create(glyph_metrics_hash, glyph_metrics_compare, NULL,
-            (ItemSize) NULL, sizeof(GlyphMetricsHashKey),
-            sizeof(GlyphMetricsHashValue));
+    hashmap_done(composite_cache);
 }
 
-Cache *ass_bitmap_cache_create(void)
+Hashmap *ass_composite_cache_reset(Hashmap *composite_cache)
 {
-    return ass_cache_create(bitmap_hash, bitmap_compare, bitmap_destruct,
-            bitmap_size, sizeof(BitmapHashKey), sizeof(BitmapHashValue));
-}
+    ASS_Library *lib = composite_cache->library;
 
-Cache *ass_composite_cache_create(void)
-{
-    return ass_cache_create(composite_hash, composite_compare,
-            composite_destruct, (ItemSize)NULL, sizeof(CompositeHashKey),
-            sizeof(CompositeHashValue));
+    ass_composite_cache_done(composite_cache);
+    return ass_composite_cache_init(lib);
 }
Index: libass/ass_cache.h
===================================================================
--- libass/ass_cache.h	(revision 34728)
+++ libass/ass_cache.h	(working copy)
@@ -1,6 +1,5 @@
 /*
  * Copyright (C) 2006 Evgeniy Stepanov <eugeni.stepanov@gmail.com>
- * Copyright (C) 2011 Grigori Goronzy <greg@chown.ath.cx>
  *
  * This file is part of libass.
  *
@@ -24,81 +23,95 @@
 #include "ass_font.h"
 #include "ass_bitmap.h"
 
-typedef struct cache Cache;
+typedef void (*HashmapItemDtor) (void *key, size_t key_size,
+                                 void *value, size_t value_size);
+typedef int (*HashmapKeyCompare) (void *key1, void *key2,
+                                  size_t key_size);
+typedef unsigned (*HashmapHash) (void *key, size_t key_size);
 
-// cache values
+typedef struct hashmap_item {
+    void *key;
+    void *value;
+    struct hashmap_item *next;
+} HashmapItem;
+typedef HashmapItem *hashmap_item_p;
 
 typedef struct {
+    int nbuckets;
+    size_t key_size, value_size;
+    hashmap_item_p *root;
+    HashmapItemDtor item_dtor;      // a destructor for hashmap key/value pairs
+    HashmapKeyCompare key_compare;
+    HashmapHash hash;
+    size_t cache_size;
+    // stats
+    int hit_count;
+    int miss_count;
+    int count;
+    ASS_Library *library;
+} Hashmap;
+
+Hashmap *hashmap_init(ASS_Library *library, size_t key_size,
+                      size_t value_size, int nbuckets,
+                      HashmapItemDtor item_dtor,
+                      HashmapKeyCompare key_compare,
+                      HashmapHash hash);
+void hashmap_done(Hashmap *map);
+void *hashmap_insert(Hashmap *map, void *key, void *value);
+void *hashmap_find(Hashmap *map, void *key);
+
+Hashmap *ass_font_cache_init(ASS_Library *library);
+ASS_Font *ass_font_cache_find(Hashmap *, ASS_FontDesc *desc);
+void *ass_font_cache_add(Hashmap *, ASS_Font *font);
+void ass_font_cache_done(Hashmap *);
+
+// Create definitions for bitmap_hash_key and glyph_hash_key
+#define CREATE_STRUCT_DEFINITIONS
+#include "ass_cache_template.h"
+
+typedef struct {
     Bitmap *bm;               // the actual bitmaps
     Bitmap *bm_o;
     Bitmap *bm_s;
 } BitmapHashValue;
 
+Hashmap *ass_bitmap_cache_init(ASS_Library *library);
+void *cache_add_bitmap(Hashmap *, BitmapHashKey *key,
+                       BitmapHashValue *val);
+BitmapHashValue *cache_find_bitmap(Hashmap *bitmap_cache,
+                                   BitmapHashKey *key);
+Hashmap *ass_bitmap_cache_reset(Hashmap *bitmap_cache);
+void ass_bitmap_cache_done(Hashmap *bitmap_cache);
+
+
 typedef struct {
     unsigned char *a;
     unsigned char *b;
 } CompositeHashValue;
 
+Hashmap *ass_composite_cache_init(ASS_Library *library);
+void *cache_add_composite(Hashmap *, CompositeHashKey *key,
+                          CompositeHashValue *val);
+CompositeHashValue *cache_find_composite(Hashmap *composite_cache,
+                                         CompositeHashKey *key);
+Hashmap *ass_composite_cache_reset(Hashmap *composite_cache);
+void ass_composite_cache_done(Hashmap *composite_cache);
+
+
 typedef struct {
-    FT_Library lib;
-    FT_Outline *outline;
-    FT_Outline *border;
+    FT_Glyph glyph;
+    FT_Glyph outline_glyph;
     FT_BBox bbox_scaled;        // bbox after scaling, but before rotation
-    FT_Vector advance;          // 26.6, advance distance to the next outline in line
-    int asc, desc;              // ascender/descender
-} OutlineHashValue;
+    FT_Vector advance;          // 26.6, advance distance to the next bitmap in line
+    int asc, desc;              // ascender/descender of a drawing
+} GlyphHashValue;
 
-typedef struct {
-    FT_Glyph_Metrics metrics;
-} GlyphMetricsHashValue;
+Hashmap *ass_glyph_cache_init(ASS_Library *library);
+void *cache_add_glyph(Hashmap *, GlyphHashKey *key,
+                      GlyphHashValue *val);
+GlyphHashValue *cache_find_glyph(Hashmap *glyph_cache,
+                                 GlyphHashKey *key);
+Hashmap *ass_glyph_cache_reset(Hashmap *glyph_cache);
+void ass_glyph_cache_done(Hashmap *glyph_cache);
 
-// Create definitions for bitmap, outline and composite hash keys
-#define CREATE_STRUCT_DEFINITIONS
-#include "ass_cache_template.h"
-
-// Type-specific function pointers
-typedef unsigned(*HashFunction)(void *key, size_t key_size);
-typedef size_t(*ItemSize)(void *value, size_t value_size);
-typedef unsigned(*HashCompare)(void *a, void *b, size_t key_size);
-typedef void(*CacheItemDestructor)(void *key, void *value);
-
-// cache hash keys
-
-typedef struct outline_hash_key {
-    enum {
-        OUTLINE_GLYPH,
-        OUTLINE_DRAWING,
-    } type;
-    union {
-        GlyphHashKey glyph;
-        DrawingHashKey drawing;
-    } u;
-} OutlineHashKey;
-
-typedef struct bitmap_hash_key {
-    enum {
-        BITMAP_OUTLINE,
-        BITMAP_CLIP,
-    } type;
-    union {
-        OutlineBitmapHashKey outline;
-        ClipMaskHashKey clip;
-    } u;
-} BitmapHashKey;
-
-Cache *ass_cache_create(HashFunction hash_func, HashCompare compare_func,
-                        CacheItemDestructor destruct_func, ItemSize size_func,
-                        size_t key_size, size_t value_size);
-void *ass_cache_put(Cache *cache, void *key, void *value);
-void *ass_cache_get(Cache *cache, void *key);
-int ass_cache_empty(Cache *cache, size_t max_size);
-void ass_cache_stats(Cache *cache, size_t *size, unsigned *hits,
-                     unsigned *misses, unsigned *count);
-void ass_cache_done(Cache *cache);
-Cache *ass_font_cache_create(void);
-Cache *ass_outline_cache_create(void);
-Cache *ass_glyph_metrics_cache_create(void);
-Cache *ass_bitmap_cache_create(void);
-Cache *ass_composite_cache_create(void);
-
 #endif                          /* LIBASS_CACHE_H */
Index: libass/ass_cache_template.h
===================================================================
--- libass/ass_cache_template.h	(revision 34728)
+++ libass/ass_cache_template.h	(working copy)
@@ -4,8 +4,6 @@
     typedef struct structname {
 #define GENERIC(type, member) \
         type member;
-#define STRING(member) \
-        char *member;
 #define FTVECTOR(member) \
         FT_Vector member;
 #define BITMAPHASHKEY(member) \
@@ -16,15 +14,13 @@
 #elif defined(CREATE_COMPARISON_FUNCTIONS)
 #undef CREATE_COMPARISON_FUNCTIONS
 #define START(funcname, structname) \
-    static unsigned funcname##_compare(void *key1, void *key2, size_t key_size) \
+    static int funcname##_compare(void *key1, void *key2, size_t key_size) \
     { \
         struct structname *a = key1; \
         struct structname *b = key2; \
         return // conditions follow
 #define GENERIC(type, member) \
             a->member == b->member &&
-#define STRING(member) \
-            strcmp(a->member, b->member) == 0 &&
 #define FTVECTOR(member) \
             a->member.x == b->member.x && a->member.y == b->member.y &&
 #define BITMAPHASHKEY(member) \
@@ -42,8 +38,6 @@
         unsigned hval = FNV1_32A_INIT;
 #define GENERIC(type, member) \
         hval = fnv_32a_buf(&p->member, sizeof(p->member), hval);
-#define STRING(member) \
-        hval = fnv_32a_str(p->member, hval);
 #define FTVECTOR(member) GENERIC(, member.x); GENERIC(, member.y);
 #define BITMAPHASHKEY(member) { \
         unsigned temp = bitmap_hash(&p->member, sizeof(p->member)); \
@@ -59,11 +53,19 @@
 
 
 
-// describes an outline bitmap
-START(outline_bitmap, outline_bitmap_hash_key)
-    GENERIC(OutlineHashValue *, outline)
+// describes a bitmap; bitmaps with equivalents structs are considered identical
+START(bitmap, bitmap_hash_key)
+    GENERIC(char, bitmap) // bool : true = bitmap, false = outline
+    GENERIC(ASS_Font *, font)
+    GENERIC(double, size) // font size
+    GENERIC(uint32_t, ch) // character code
+    FTVECTOR(outline) // border width, 16.16 fixed point value
+    GENERIC(int, bold)
+    GENERIC(int, italic)
     GENERIC(char, be) // blur edges
     GENERIC(double, blur) // gaussian blur
+    GENERIC(unsigned, scale_x) // 16.16
+    GENERIC(unsigned, scale_y) // 16.16
     GENERIC(int, frx) // signed 16.16
     GENERIC(int, fry) // signed 16.16
     GENERIC(int, frz) // signed 16.16
@@ -76,49 +78,26 @@
     GENERIC(int, shift_y)
     FTVECTOR(advance) // subpixel shift vector
     FTVECTOR(shadow_offset) // shadow subpixel shift
-END(OutlineBitmapHashKey)
+    GENERIC(unsigned, drawing_hash) // hashcode of a drawing
+    GENERIC(unsigned, flags)    // glyph decoration
+    GENERIC(unsigned, border_style)
+END(BitmapHashKey)
 
-// describe a clip mask bitmap
-START(clip_bitmap, clip_bitmap_hash_key)
-    STRING(text)
-END(ClipMaskHashKey)
-
 // describes an outline glyph
 START(glyph, glyph_hash_key)
     GENERIC(ASS_Font *, font)
     GENERIC(double, size) // font size
-    GENERIC(int, face_index)
-    GENERIC(int, glyph_index)
+    GENERIC(uint32_t, ch) // character code
     GENERIC(int, bold)
     GENERIC(int, italic)
     GENERIC(unsigned, scale_x) // 16.16
     GENERIC(unsigned, scale_y) // 16.16
     FTVECTOR(outline) // border width, 16.16
+    GENERIC(unsigned, drawing_hash) // hashcode of a drawing
     GENERIC(unsigned, flags)    // glyph decoration flags
     GENERIC(unsigned, border_style)
 END(GlyphHashKey)
 
-START(glyph_metrics, glyph_metrics_hash_key)
-    GENERIC(ASS_Font *, font)
-    GENERIC(double, size)
-    GENERIC(int, face_index)
-    GENERIC(int, glyph_index)
-    GENERIC(unsigned, scale_x)
-    GENERIC(unsigned, scale_y)
-END(GlyphMetricsHashKey)
-
-// describes an outline drawing
-START(drawing, drawing_hash_key)
-    GENERIC(unsigned, scale_x)
-    GENERIC(unsigned, scale_y)
-    GENERIC(int, pbo)
-    FTVECTOR(outline)
-    GENERIC(unsigned, border_style)
-    GENERIC(int, scale)
-    GENERIC(unsigned, hash)
-    STRING(text)
-END(DrawingHashKey)
-
 // Cache for composited bitmaps
 START(composite, composite_hash_key)
     GENERIC(int, aw)
@@ -138,7 +117,6 @@
 
 #undef START
 #undef GENERIC
-#undef STRING
 #undef FTVECTOR
 #undef BITMAPHASHKEY
 #undef END
Index: libass/ass_drawing.c
===================================================================
--- libass/ass_drawing.c	(revision 34728)
+++ libass/ass_drawing.c	(working copy)
@@ -17,11 +17,13 @@
  */
 
 #include <ft2build.h>
+#include FT_GLYPH_H
 #include FT_OUTLINE_H
 #include FT_BBOX_H
 #include <math.h>
 
 #include "ass_utils.h"
+#include "ass_font.h"
 #include "ass_drawing.h"
 
 #define CURVE_ACCURACY 64.0
@@ -29,12 +31,35 @@
 #define GLYPH_INITIAL_CONTOURS 5
 
 /*
+ * \brief Get and prepare a FreeType glyph
+ */
+static void drawing_make_glyph(ASS_Drawing *drawing, void *fontconfig_priv,
+                               ASS_Font *font)
+{
+    FT_OutlineGlyph glyph;
+
+    // This is hacky...
+    glyph = (FT_OutlineGlyph) ass_font_get_glyph(fontconfig_priv, font,
+                                                 (uint32_t) ' ', 0, 0);
+    if (glyph) {
+        FT_Outline_Done(drawing->ftlibrary, &glyph->outline);
+        FT_Outline_New(drawing->ftlibrary, GLYPH_INITIAL_POINTS,
+                       GLYPH_INITIAL_CONTOURS, &glyph->outline);
+
+        glyph->outline.n_contours = 0;
+        glyph->outline.n_points = 0;
+        glyph->root.advance.x = glyph->root.advance.y = 0;
+    }
+    drawing->glyph = glyph;
+}
+
+/*
  * \brief Add a single point to a contour.
  */
 static inline void drawing_add_point(ASS_Drawing *drawing,
                                      FT_Vector *point)
 {
-    FT_Outline *ol = &drawing->outline;
+    FT_Outline *ol = &drawing->glyph->outline;
 
     if (ol->n_points >= drawing->max_points) {
         drawing->max_points *= 2;
@@ -50,11 +75,11 @@
 }
 
 /*
- * \brief Close a contour and check outline size overflow.
+ * \brief Close a contour and check glyph size overflow.
  */
 static inline void drawing_close_shape(ASS_Drawing *drawing)
 {
-    FT_Outline *ol = &drawing->outline;
+    FT_Outline *ol = &drawing->glyph->outline;
 
     if (ol->n_contours >= drawing->max_contours) {
         drawing->max_contours *= 2;
@@ -82,13 +107,13 @@
 
 /*
  * \brief Finish a drawing.  This only sets the horizontal advance according
- * to the outline's bbox at the moment.
+ * to the glyph's bbox at the moment.
  */
 static void drawing_finish(ASS_Drawing *drawing, int raw_mode)
 {
     int i, offset;
     FT_BBox bbox = drawing->cbox;
-    FT_Outline *ol = &drawing->outline;
+    FT_Outline *ol = &drawing->glyph->outline;
 
     // Close the last contour
     drawing_close_shape(drawing);
@@ -101,7 +126,7 @@
     if (raw_mode)
         return;
 
-    drawing->advance.x = bbox.xMax - bbox.xMin;
+    drawing->glyph->root.advance.x = d6_to_d16(bbox.xMax - bbox.xMin);
 
     drawing->desc = double_to_d6(-drawing->pbo * drawing->scale_y);
     drawing->asc = bbox.yMax - bbox.yMin + drawing->desc;
@@ -330,7 +355,8 @@
 /*
  * \brief Create and initialize a new drawing and return it
  */
-ASS_Drawing *ass_drawing_new(ASS_Library *lib, FT_Library ftlib)
+ASS_Drawing *ass_drawing_new(void *fontconfig_priv, ASS_Font *font,
+                             FT_Library lib)
 {
     ASS_Drawing *drawing;
 
@@ -339,18 +365,17 @@
     drawing->size = DRAWING_INITIAL_SIZE;
     drawing->cbox.xMin = drawing->cbox.yMin = INT_MAX;
     drawing->cbox.xMax = drawing->cbox.yMax = INT_MIN;
-    drawing->ftlibrary = ftlib;
-    drawing->library   = lib;
+    drawing->fontconfig_priv = fontconfig_priv;
+    drawing->font = font;
+    drawing->ftlibrary = lib;
+    if (font)
+        drawing->library = font->library;
+
     drawing->scale_x = 1.;
     drawing->scale_y = 1.;
     drawing->max_contours = GLYPH_INITIAL_CONTOURS;
     drawing->max_points = GLYPH_INITIAL_POINTS;
 
-    FT_Outline_New(drawing->ftlibrary, GLYPH_INITIAL_POINTS,
-            GLYPH_INITIAL_CONTOURS, &drawing->outline);
-    drawing->outline.n_contours = 0;
-    drawing->outline.n_points = 0;
-
     return drawing;
 }
 
@@ -361,7 +386,6 @@
 {
     if (drawing) {
         free(drawing->text);
-        FT_Outline_Done(drawing->ftlibrary, &drawing->outline);
     }
     free(drawing);
 }
@@ -392,12 +416,17 @@
 /*
  * \brief Convert token list to outline.  Calls the line and curve evaluators.
  */
-FT_Outline *ass_drawing_parse(ASS_Drawing *drawing, int raw_mode)
+FT_OutlineGlyph *ass_drawing_parse(ASS_Drawing *drawing, int raw_mode)
 {
     int started = 0;
     ASS_DrawingToken *token;
     FT_Vector pen = {0, 0};
 
+    if (drawing->font)
+        drawing_make_glyph(drawing, drawing->fontconfig_priv, drawing->font);
+    if (!drawing->glyph)
+        return NULL;
+
     drawing->tokens = drawing_tokenize(drawing->text);
     drawing_prepare(drawing);
 
@@ -457,5 +486,5 @@
 
     drawing_finish(drawing, raw_mode);
     drawing_free_tokens(drawing->tokens);
-    return &drawing->outline;
+    return &drawing->glyph;
 }
Index: libass/ass_drawing.h
===================================================================
--- libass/ass_drawing.h	(revision 34728)
+++ libass/ass_drawing.h	(working copy)
@@ -20,7 +20,7 @@
 #define LIBASS_DRAWING_H
 
 #include <ft2build.h>
-#include FT_OUTLINE_H
+#include FT_GLYPH_H
 
 #include "ass.h"
 
@@ -53,12 +53,13 @@
     double scale_y;     // FontScaleY
     int asc;            // ascender
     int desc;           // descender
-    FT_Outline outline; // target outline
-    FT_Vector advance;  // advance (from cbox)
+    FT_OutlineGlyph glyph;  // the "fake" glyph created for later rendering
     int hash;           // hash value (for caching)
 
     // private
     FT_Library ftlibrary;   // needed for font ops
+    ASS_Font *font;         // dito
+    void *fontconfig_priv;  // dito
     ASS_Library *library;
     int size;           // current buffer size
     ASS_DrawingToken *tokens;    // tokenized drawing
@@ -69,10 +70,11 @@
     FT_BBox cbox;   // bounding box, or let's say... VSFilter's idea of it
 } ASS_Drawing;
 
-ASS_Drawing *ass_drawing_new(ASS_Library *lib, FT_Library ftlib);
+ASS_Drawing *ass_drawing_new(void *fontconfig_priv, ASS_Font *font,
+                             FT_Library lib);
 void ass_drawing_free(ASS_Drawing* drawing);
 void ass_drawing_add_char(ASS_Drawing* drawing, char symbol);
 void ass_drawing_hash(ASS_Drawing* drawing);
-FT_Outline *ass_drawing_parse(ASS_Drawing *drawing, int raw_mode);
+FT_OutlineGlyph *ass_drawing_parse(ASS_Drawing *drawing, int raw_mode);
 
 #endif /* LIBASS_DRAWING_H */
Index: libass/ass_font.c
===================================================================
--- libass/ass_font.c	(revision 34728)
+++ libass/ass_font.c	(working copy)
@@ -30,10 +30,13 @@
 #include "ass.h"
 #include "ass_library.h"
 #include "ass_font.h"
+#include "ass_bitmap.h"
+#include "ass_cache.h"
 #include "ass_fontconfig.h"
 #include "ass_utils.h"
-#include "ass_shaper.h"
 
+#define VERTICAL_LOWER_BOUND 0x02f1
+
 /**
  * Select a good charmap, prefer Microsoft Unicode charmaps.
  * Otherwise, let FreeType decide.
@@ -88,6 +91,8 @@
     return -1;
 }
 
+static void face_set_size(FT_Face face, double size);
+
 static void buggy_font_workaround(FT_Face face)
 {
     // Some fonts have zero Ascender/Descender fields in 'hhea' table.
@@ -156,7 +161,7 @@
     buggy_font_workaround(face);
 
     font->faces[font->n_faces++] = face;
-    ass_face_set_size(face, font->size);
+    face_set_size(face, font->size);
     free(path);
     return font->n_faces - 1;
 }
@@ -164,7 +169,7 @@
 /**
  * \brief Create a new ASS_Font according to "desc" argument
  */
-ASS_Font *ass_font_new(Cache *font_cache, ASS_Library *library,
+ASS_Font *ass_font_new(void *font_cache, ASS_Library *library,
                        FT_Library ftlibrary, void *fc_priv,
                        ASS_FontDesc *desc)
 {
@@ -172,13 +177,12 @@
     ASS_Font *fontp;
     ASS_Font font;
 
-    fontp = ass_cache_get(font_cache, desc);
+    fontp = ass_font_cache_find((Hashmap *) font_cache, desc);
     if (fontp)
         return fontp;
 
     font.library = library;
     font.ftlibrary = ftlibrary;
-    font.shaper_priv = NULL;
     font.n_faces = 0;
     font.desc.family = strdup(desc->family);
     font.desc.treat_family_as_pattern = desc->treat_family_as_pattern;
@@ -195,7 +199,7 @@
         free(font.desc.family);
         return 0;
     } else
-        return ass_cache_put(font_cache, &font.desc, &font);
+        return ass_font_cache_add((Hashmap *) font_cache, &font);
 }
 
 /**
@@ -212,7 +216,7 @@
     }
 }
 
-void ass_face_set_size(FT_Face face, double size)
+static void face_set_size(FT_Face face, double size)
 {
     TT_HoriHeader *hori = FT_Get_Sfnt_Table(face, ft_sfnt_hhea);
     TT_OS2 *os2 = FT_Get_Sfnt_Table(face, ft_sfnt_os2);
@@ -247,7 +251,7 @@
     if (font->size != size) {
         font->size = size;
         for (i = 0; i < font->n_faces; ++i)
-            ass_face_set_size(font->faces[i], size);
+            face_set_size(font->faces[i], size);
     }
 }
 
@@ -272,6 +276,9 @@
                 *asc = FT_MulFix(face->ascender, y_scale);
                 *desc = FT_MulFix(-face->descender, y_scale);
             }
+            if (font->desc.vertical && ch >= VERTICAL_LOWER_BOUND) {
+                *asc = FT_MulFix(face->max_advance_width, y_scale);
+            }
             return;
         }
     }
@@ -381,25 +388,6 @@
     return 0;
 }
 
-void outline_copy(FT_Library lib, FT_Outline *source, FT_Outline **dest)
-{
-    if (source == NULL) {
-        *dest = NULL;
-        return;
-    }
-    *dest = calloc(1, sizeof(**dest));
-
-    FT_Outline_New(lib, source->n_points, source->n_contours, *dest);
-    FT_Outline_Copy(source, *dest);
-}
-
-void outline_free(FT_Library lib, FT_Outline *outline)
-{
-    if (outline)
-        FT_Outline_Done(lib, outline);
-    free(outline);
-}
-
 /**
  * Slightly embold a glyph without touching its metrics
  */
@@ -417,43 +405,33 @@
 }
 
 /**
- * \brief Get glyph and face index
- * Finds a face that has the requested codepoint and returns both face
- * and glyph index.
- */
-int ass_font_get_index(void *fcpriv, ASS_Font *font, uint32_t symbol,
-                       int *face_index, int *glyph_index)
+ * \brief Get a glyph
+ * \param ch character code
+ **/
+FT_Glyph ass_font_get_glyph(void *fontconfig_priv, ASS_Font *font,
+                            uint32_t ch, ASS_Hinting hinting, int deco)
 {
+    int error;
     int index = 0;
     int i;
+    FT_Glyph glyph;
     FT_Face face = 0;
+    int flags = 0;
+    int vertical = font->desc.vertical;
 
-    *glyph_index = 0;
-
-    if (symbol < 0x20) {
-        *face_index = 0;
+    if (ch < 0x20)
         return 0;
-    }
     // Handle NBSP like a regular space when rendering the glyph
-    if (symbol == 0xa0)
-        symbol = ' ';
-    if (font->n_faces == 0) {
-        *face_index = 0;
+    if (ch == 0xa0)
+        ch = ' ';
+    if (font->n_faces == 0)
         return 0;
-    }
 
-    // try with the requested face
-    if (*face_index < font->n_faces) {
-        face = font->faces[*face_index];
-        index = FT_Get_Char_Index(face, symbol);
-    }
-
-    // not found in requested face, try all others
-    for (i = 0; i < font->n_faces && index == 0; ++i) {
+    for (i = 0; i < font->n_faces; ++i) {
         face = font->faces[i];
-        index = FT_Get_Char_Index(face, symbol);
+        index = FT_Get_Char_Index(face, ch);
         if (index)
-            *face_index = i;
+            break;
     }
 
 #ifdef CONFIG_FONTCONFIG
@@ -461,51 +439,31 @@
         int face_idx;
         ass_msg(font->library, MSGL_INFO,
                 "Glyph 0x%X not found, selecting one more "
-                "font for (%s, %d, %d)", symbol, font->desc.family,
+                "font for (%s, %d, %d)", ch, font->desc.family,
                 font->desc.bold, font->desc.italic);
-        face_idx = *face_index = add_face(fcpriv, font, symbol);
+        face_idx = add_face(fontconfig_priv, font, ch);
         if (face_idx >= 0) {
             face = font->faces[face_idx];
-            index = FT_Get_Char_Index(face, symbol);
+            index = FT_Get_Char_Index(face, ch);
             if (index == 0 && face->num_charmaps > 0) {
                 int i;
                 ass_msg(font->library, MSGL_WARN,
-                    "Glyph 0x%X not found, broken font? Trying all charmaps", symbol);
+                    "Glyph 0x%X not found, broken font? Trying all charmaps", ch);
                 for (i = 0; i < face->num_charmaps; i++) {
                     FT_Set_Charmap(face, face->charmaps[i]);
-                    if ((index = FT_Get_Char_Index(face, symbol)) != 0) break;
+                    if ((index = FT_Get_Char_Index(face, ch)) != 0) break;
                 }
             }
             if (index == 0) {
                 ass_msg(font->library, MSGL_ERR,
                         "Glyph 0x%X not found in font for (%s, %d, %d)",
-                        symbol, font->desc.family, font->desc.bold,
+                        ch, font->desc.family, font->desc.bold,
                         font->desc.italic);
             }
         }
     }
 #endif
-    // FIXME: make sure we have a valid face_index. this is a HACK.
-    *face_index  = FFMAX(*face_index, 0);
-    *glyph_index = index;
 
-    return 1;
-}
-
-/**
- * \brief Get a glyph
- * \param ch character code
- **/
-FT_Glyph ass_font_get_glyph(void *fontconfig_priv, ASS_Font *font,
-                            uint32_t ch, int face_index, int index,
-                            ASS_Hinting hinting, int deco)
-{
-    int error;
-    FT_Glyph glyph;
-    FT_Face face = font->faces[face_index];
-    int flags = 0;
-    int vertical = font->desc.vertical;
-
     flags = FT_LOAD_NO_BITMAP | FT_LOAD_IGNORE_GLOBAL_ADVANCE_WIDTH
             | FT_LOAD_IGNORE_TRANSFORM;
     switch (hinting) {
@@ -547,16 +505,10 @@
     // Rotate glyph, if needed
     if (vertical && ch >= VERTICAL_LOWER_BOUND) {
         FT_Matrix m = { 0, double_to_d16(-1.0), double_to_d16(1.0), 0 };
-        TT_OS2 *os2 = FT_Get_Sfnt_Table(face, ft_sfnt_os2);
-        int desc = 0;
-
-        if (os2)
-            desc = FT_MulFix(os2->sTypoDescender, face->size->metrics.y_scale);
-
-        FT_Outline_Translate(&((FT_OutlineGlyph) glyph)->outline, 0, -desc);
         FT_Outline_Transform(&((FT_OutlineGlyph) glyph)->outline, &m);
         FT_Outline_Translate(&((FT_OutlineGlyph) glyph)->outline,
-                             face->glyph->metrics.vertAdvance, desc);
+                             face->glyph->metrics.vertAdvance,
+                             0);
         glyph->advance.x = face->glyph->linearVertAdvance;
     }
 
@@ -609,8 +561,6 @@
     for (i = 0; i < font->n_faces; ++i)
         if (font->faces[i])
             FT_Done_Face(font->faces[i]);
-    if (font->shaper_priv)
-        ass_shaper_font_data_free(font->shaper_priv);
     free(font->desc.family);
     free(font);
 }
@@ -668,9 +618,9 @@
  * \param border_x border size, x direction, d6 format
  * \param border_x border size, y direction, d6 format
  */
-void fix_freetype_stroker(FT_Outline *outline, int border_x, int border_y)
+void fix_freetype_stroker(FT_OutlineGlyph glyph, int border_x, int border_y)
 {
-    int nc = outline->n_contours;
+    int nc = glyph->outline.n_contours;
     int begin, stop;
     char modified = 0;
     char *valid_cont = malloc(nc);
@@ -680,14 +630,14 @@
     int i, j;
     int inside_direction;
 
-    inside_direction = FT_Outline_Get_Orientation(outline) ==
+    inside_direction = FT_Outline_Get_Orientation(&glyph->outline) ==
         FT_ORIENTATION_TRUETYPE;
 
     // create a list of cboxes of the contours
     for (i = 0; i < nc; i++) {
         start = end + 1;
-        end = outline->contours[i];
-        get_contour_cbox(&boxes[i], outline->points, start, end);
+        end = glyph->outline.contours[i];
+        get_contour_cbox(&boxes[i], glyph->outline.points, start, end);
     }
 
     // for each contour, check direction and whether it's "outside"
@@ -695,8 +645,8 @@
     end = -1;
     for (i = 0; i < nc; i++) {
         start = end + 1;
-        end = outline->contours[i];
-        int dir = get_contour_direction(outline->points, start, end);
+        end = glyph->outline.contours[i];
+        int dir = get_contour_direction(glyph->outline.points, start, end);
         valid_cont[i] = 1;
         if (dir == inside_direction) {
             for (j = 0; j < nc; j++) {
@@ -712,19 +662,19 @@
              * inside of - assume the font is buggy and it should be
              * an "outside" contour, and reverse it */
             for (j = 0; j < (end + 1 - start) / 2; j++) {
-                FT_Vector temp = outline->points[start + j];
-                char temp2 = outline->tags[start + j];
-                outline->points[start + j] = outline->points[end - j];
-                outline->points[end - j] = temp;
-                outline->tags[start + j] = outline->tags[end - j];
-                outline->tags[end - j] = temp2;
+                FT_Vector temp = glyph->outline.points[start + j];
+                char temp2 = glyph->outline.tags[start + j];
+                glyph->outline.points[start + j] = glyph->outline.points[end - j];
+                glyph->outline.points[end - j] = temp;
+                glyph->outline.tags[start + j] = glyph->outline.tags[end - j];
+                glyph->outline.tags[end - j] = temp2;
             }
             dir ^= 1;
         }
         check_inside:
         if (dir == inside_direction) {
             FT_BBox box;
-            get_contour_cbox(&box, outline->points, start, end);
+            get_contour_cbox(&box, glyph->outline.points, start, end);
             int width = box.xMax - box.xMin;
             int height = box.yMax - box.yMin;
             if (width < border_x * 2 || height < border_y * 2) {
@@ -737,12 +687,13 @@
     // if we need to modify the outline, rewrite it and skip
     // the contours that we determined should be removed.
     if (modified) {
+        FT_Outline *outline = &glyph->outline;
         int p = 0, c = 0;
         for (i = 0; i < nc; i++) {
             if (!valid_cont[i])
                 continue;
-            begin = (i == 0) ? 0 : outline->contours[i - 1] + 1;
-            stop = outline->contours[i];
+            begin = (i == 0) ? 0 : glyph->outline.contours[i - 1] + 1;
+            stop = glyph->outline.contours[i];
             for (j = begin; j <= stop; j++) {
                 outline->points[p].x = outline->points[j].x;
                 outline->points[p].y = outline->points[j].y;
Index: libass/ass_font.h
===================================================================
--- libass/ass_font.h	(revision 34728)
+++ libass/ass_font.h	(working copy)
@@ -22,19 +22,13 @@
 #include <stdint.h>
 #include <ft2build.h>
 #include FT_GLYPH_H
-#include FT_OUTLINE_H
-
 #include "ass.h"
 #include "ass_types.h"
 
-#define VERTICAL_LOWER_BOUND 0x02f1
-
 #define ASS_FONT_MAX_FACES 10
 #define DECO_UNDERLINE 1
 #define DECO_STRIKETHROUGH 2
 
-typedef struct ass_shaper_font_data ASS_ShaperFontData;
-
 typedef struct {
     char *family;
     unsigned bold;
@@ -48,33 +42,25 @@
     ASS_Library *library;
     FT_Library ftlibrary;
     FT_Face faces[ASS_FONT_MAX_FACES];
-    ASS_ShaperFontData *shaper_priv;
     int n_faces;
     double scale_x, scale_y;    // current transform
     FT_Vector v;                // current shift
     double size;
 } ASS_Font;
 
-#include "ass_cache.h"
-
-ASS_Font *ass_font_new(Cache *font_cache, ASS_Library *library,
+// FIXME: passing the hashmap via a void pointer is very ugly.
+ASS_Font *ass_font_new(void *font_cache, ASS_Library *library,
                        FT_Library ftlibrary, void *fc_priv,
                        ASS_FontDesc *desc);
 void ass_font_set_transform(ASS_Font *font, double scale_x,
                             double scale_y, FT_Vector *v);
-void ass_face_set_size(FT_Face face, double size);
 void ass_font_set_size(ASS_Font *font, double size);
 void ass_font_get_asc_desc(ASS_Font *font, uint32_t ch, int *asc,
                            int *desc);
-int ass_font_get_index(void *fcpriv, ASS_Font *font, uint32_t symbol,
-                       int *face_index, int *glyph_index);
 FT_Glyph ass_font_get_glyph(void *fontconfig_priv, ASS_Font *font,
-                            uint32_t ch, int face_index, int index,
-                            ASS_Hinting hinting, int deco);
+                            uint32_t ch, ASS_Hinting hinting, int flags);
 FT_Vector ass_font_get_kerning(ASS_Font *font, uint32_t c1, uint32_t c2);
 void ass_font_free(ASS_Font *font);
-void fix_freetype_stroker(FT_Outline *outline, int border_x, int border_y);
-void outline_copy(FT_Library lib, FT_Outline *source, FT_Outline **dest);
-void outline_free(FT_Library lib, FT_Outline *outline);
+void fix_freetype_stroker(FT_OutlineGlyph glyph, int border_x, int border_y);
 
 #endif                          /* LIBASS_FONT_H */
Index: libass/ass_library.c
===================================================================
--- libass/ass_library.c	(revision 34728)
+++ libass/ass_library.c	(working copy)
@@ -78,7 +78,6 @@
             free(*p);
     }
     free(priv->style_overrides);
-    priv->style_overrides = NULL;
 
     if (!list)
         return;
Index: libass/ass_parse.c
===================================================================
--- libass/ass_parse.c	(revision 34728)
+++ libass/ass_parse.c	(working copy)
@@ -47,18 +47,17 @@
         return 0;
 }
 
-double ensure_font_size(ASS_Renderer *priv, double size)
+static void change_font_size(ASS_Renderer *render_priv, double sz)
 {
+    double size = sz * render_priv->font_scale;
+
     if (size < 1)
         size = 1;
-    else if (size > priv->height * 2)
-        size = priv->height * 2;
+    else if (size > render_priv->height * 2)
+        size = render_priv->height * 2;
 
-    return size;
-}
+    ass_font_set_size(render_priv->state.font, size);
 
-static void change_font_size(ASS_Renderer *render_priv, double sz)
-{
     render_priv->state.font_size = sz;
 }
 
@@ -190,18 +189,17 @@
 {
     unsigned a;
     double cf;
-
-    if (now < t1) {
+    if (now <= t1) {
         a = a1;
     } else if (now >= t4) {
         a = a3;
-    } else if (now < t2 && t2 > t1) {
+    } else if (now < t2) {      // and > t1
         cf = ((double) (now - t1)) / (t2 - t1);
         a = a1 * (1 - cf) + a2 * cf;
-    } else if (now >= t3 && t4 > t3) {
+    } else if (now > t3) {
         cf = ((double) (now - t3)) / (t4 - t3);
         a = a2 * (1 - cf) + a3 * cf;
-    } else {                    // t2 <= now < t3
+    } else {                    // t2 <= now <= t3
         a = a2;
     }
 
@@ -218,9 +216,13 @@
     int res = 0;
     ASS_Drawing *drawing = render_priv->state.clip_drawing;
 
+    if (drawing && drawing->glyph)
+        FT_Done_Glyph((FT_Glyph) drawing->glyph);
     ass_drawing_free(drawing);
-    render_priv->state.clip_drawing =
-        ass_drawing_new(render_priv->library, render_priv->ftlibrary);
+    render_priv->state.clip_drawing = ass_drawing_new(
+        render_priv->fontconfig_priv,
+        render_priv->state.font,
+        render_priv->ftlibrary);
     drawing = render_priv->state.clip_drawing;
     skipopt('(');
     res = mystrtoi(&p, &scale);
@@ -257,7 +259,6 @@
         else
             val = -1.;
         change_border(render_priv, val, render_priv->state.border_y);
-        render_priv->state.bm_run_id++;
     } else if (mystrcmp(&p, "ybord")) {
         double val;
         if (mystrtod(&p, &val))
@@ -272,7 +273,6 @@
         else
             val = 0.;
         render_priv->state.shadow_x = val;
-        render_priv->state.bm_run_id++;
     } else if (mystrcmp(&p, "yshad")) {
         double val;
         if (mystrtod(&p, &val))
@@ -280,7 +280,6 @@
         else
             val = 0.;
         render_priv->state.shadow_y = val;
-        render_priv->state.bm_run_id++;
     } else if (mystrcmp(&p, "fax")) {
         double val;
         if (mystrtod(&p, &val))
@@ -332,7 +331,6 @@
             render_priv->state.blur = val;
         } else
             render_priv->state.blur = 0.0;
-        render_priv->state.bm_run_id++;
         // ASS standard tags
     } else if (mystrcmp(&p, "fsc")) {
         char tp = *p++;
@@ -393,7 +391,6 @@
         } else
             val = -1.;          // reset to default
         change_border(render_priv, val, val);
-        render_priv->state.bm_run_id++;
     } else if (mystrcmp(&p, "move")) {
         double x1, x2, y1, y2;
         long long t1, t2, delta_t, t;
@@ -495,7 +492,6 @@
             change_alpha(&render_priv->state.c[3],
                          render_priv->state.style->BackColour, pwr);
         }
-        render_priv->state.bm_run_id++;
         // FIXME: simplify
     } else if (mystrcmp(&p, "an")) {
         int val;
@@ -686,7 +682,6 @@
             val = render_priv->state.style->PrimaryColour;
         ass_msg(render_priv->library, MSGL_DBG2, "color: %X", val);
         change_color(&render_priv->state.c[0], val, pwr);
-        render_priv->state.bm_run_id++;
     } else if ((*p >= '1') && (*p <= '4') && (++p)
                && (mystrcmp(&p, "c") || mystrcmp(&p, "a"))) {
         char n = *(p - 2);
@@ -716,11 +711,9 @@
         switch (cmd) {
         case 'c':
             change_color(render_priv->state.c + cidx, val, pwr);
-            render_priv->state.bm_run_id++;
             break;
         case 'a':
             change_alpha(render_priv->state.c + cidx, val >> 24, pwr);
-            render_priv->state.bm_run_id++;
             break;
         default:
             ass_msg(render_priv->library, MSGL_WARN, "Bad command: %c%c",
@@ -740,7 +733,6 @@
             render_priv->state.be = val;
         } else
             render_priv->state.be = 0;
-        render_priv->state.bm_run_id++;
     } else if (mystrcmp(&p, "b")) {
         int b;
         if (mystrtoi(&p, &b)) {
@@ -789,21 +781,18 @@
         } else
             val = 0.;
         render_priv->state.shadow_x = render_priv->state.shadow_y = val;
-        render_priv->state.bm_run_id++;
     } else if (mystrcmp(&p, "s")) {
         int val;
         if (mystrtoi(&p, &val) && val)
             render_priv->state.flags |= DECO_STRIKETHROUGH;
         else
             render_priv->state.flags &= ~DECO_STRIKETHROUGH;
-        render_priv->state.bm_run_id++;
     } else if (mystrcmp(&p, "u")) {
         int val;
         if (mystrtoi(&p, &val) && val)
             render_priv->state.flags |= DECO_UNDERLINE;
         else
             render_priv->state.flags &= ~DECO_UNDERLINE;
-        render_priv->state.bm_run_id++;
     } else if (mystrcmp(&p, "pbo")) {
         double val = 0;
         if (mystrtod(&p, &val))
@@ -820,11 +809,6 @@
         if (!mystrtoi(&p, &val))
             val = render_priv->track->WrapStyle;
         render_priv->state.wrap_style = val;
-    } else if (mystrcmp(&p, "fe")) {
-        int val;
-        if (!mystrtoi(&p, &val))
-            val = render_priv->state.style->Encoding;
-        render_priv->state.font_encoding = val;
     }
 
     return p;
@@ -906,77 +890,6 @@
 }
 
 /**
- * \brief determine karaoke effects
- * Karaoke effects cannot be calculated during parse stage (get_next_char()),
- * so they are done in a separate step.
- * Parse stage: when karaoke style override is found, its parameters are stored in the next glyph's
- * (the first glyph of the karaoke word)'s effect_type and effect_timing.
- * This function:
- * 1. sets effect_type for all glyphs in the word (_karaoke_ word)
- * 2. sets effect_timing for all glyphs to x coordinate of the border line between the left and right karaoke parts
- * (left part is filled with PrimaryColour, right one - with SecondaryColour).
- */
-void process_karaoke_effects(ASS_Renderer *render_priv)
-{
-    GlyphInfo *cur, *cur2;
-    GlyphInfo *s1, *e1;      // start and end of the current word
-    GlyphInfo *s2;           // start of the next word
-    int i;
-    int timing;                 // current timing
-    int tm_start, tm_end;       // timings at start and end of the current word
-    int tm_current;
-    double dt;
-    int x;
-    int x_start, x_end;
-
-    tm_current = render_priv->time - render_priv->state.event->Start;
-    timing = 0;
-    s1 = s2 = 0;
-    for (i = 0; i <= render_priv->text_info.length; ++i) {
-        cur = render_priv->text_info.glyphs + i;
-        if ((i == render_priv->text_info.length)
-            || (cur->effect_type != EF_NONE)) {
-            s1 = s2;
-            s2 = cur;
-            if (s1) {
-                e1 = s2 - 1;
-                tm_start = timing + s1->effect_skip_timing;
-                tm_end = tm_start + s1->effect_timing;
-                timing = tm_end;
-                x_start = 1000000;
-                x_end = -1000000;
-                for (cur2 = s1; cur2 <= e1; ++cur2) {
-                    x_start = FFMIN(x_start, d6_to_int(cur2->bbox.xMin + cur2->pos.x));
-                    x_end = FFMAX(x_end, d6_to_int(cur2->bbox.xMax + cur2->pos.x));
-                }
-
-                dt = (tm_current - tm_start);
-                if ((s1->effect_type == EF_KARAOKE)
-                    || (s1->effect_type == EF_KARAOKE_KO)) {
-                    if (dt > 0)
-                        x = x_end + 1;
-                    else
-                        x = x_start;
-                } else if (s1->effect_type == EF_KARAOKE_KF) {
-                    dt /= (tm_end - tm_start);
-                    x = x_start + (x_end - x_start) * dt;
-                } else {
-                    ass_msg(render_priv->library, MSGL_ERR,
-                            "Unknown effect type");
-                    continue;
-                }
-
-                for (cur2 = s1; cur2 <= e1; ++cur2) {
-                    cur2->effect_type = s1->effect_type;
-                    cur2->effect_timing = x - d6_to_int(cur2->pos.x);
-                }
-            }
-        }
-    }
-}
-
-
-/**
  * \brief Get next ucs4 char from string, parsing and executing style overrides
  * \param str string pointer
  * \return ucs4 code of the next char
Index: libass/ass_parse.h
===================================================================
--- libass/ass_parse.h	(revision 34728)
+++ libass/ass_parse.h	(working copy)
@@ -27,11 +27,9 @@
 #define _a(c)   ((c) & 0xFF)
 
 void update_font(ASS_Renderer *render_priv);
-double ensure_font_size(ASS_Renderer *priv, double size);
 void change_border(ASS_Renderer *render_priv, double border_x,
                    double border_y);
 void apply_transition_effects(ASS_Renderer *render_priv, ASS_Event *event);
-void process_karaoke_effects(ASS_Renderer *render_priv);
 unsigned get_next_char(ASS_Renderer *render_priv, char **str);
 extern void change_alpha(uint32_t *var, uint32_t new, double pwr);
 extern uint32_t mult_alpha(uint32_t a, uint32_t b);
Index: libass/ass_render.c
===================================================================
--- libass/ass_render.c	(revision 34728)
+++ libass/ass_render.c	(working copy)
@@ -23,13 +23,44 @@
 
 #include "ass_render.h"
 #include "ass_parse.h"
-#include "ass_shaper.h"
 
 #define MAX_GLYPHS_INITIAL 1024
 #define MAX_LINES_INITIAL 64
 #define SUBPIXEL_MASK 63
 #define SUBPIXEL_ACCURACY 7
 
+static void ass_lazy_track_init(ASS_Renderer *render_priv)
+{
+    ASS_Track *track = render_priv->track;
+
+    if (track->PlayResX && track->PlayResY)
+        return;
+    if (!track->PlayResX && !track->PlayResY) {
+        ass_msg(render_priv->library, MSGL_WARN,
+               "Neither PlayResX nor PlayResY defined. Assuming 384x288");
+        track->PlayResX = 384;
+        track->PlayResY = 288;
+    } else {
+        if (!track->PlayResY && track->PlayResX == 1280) {
+            track->PlayResY = 1024;
+            ass_msg(render_priv->library, MSGL_WARN,
+                   "PlayResY undefined, setting to %d", track->PlayResY);
+        } else if (!track->PlayResY) {
+            track->PlayResY = track->PlayResX * 3 / 4;
+            ass_msg(render_priv->library, MSGL_WARN,
+                   "PlayResY undefined, setting to %d", track->PlayResY);
+        } else if (!track->PlayResX && track->PlayResY == 1024) {
+            track->PlayResX = 1280;
+            ass_msg(render_priv->library, MSGL_WARN,
+                   "PlayResX undefined, setting to %d", track->PlayResX);
+        } else if (!track->PlayResX) {
+            track->PlayResX = track->PlayResY * 4 / 3;
+            ass_msg(render_priv->library, MSGL_WARN,
+                   "PlayResX undefined, setting to %d", track->PlayResX);
+        }
+    }
+}
+
 ASS_Renderer *ass_renderer_init(ASS_Library *library)
 {
     int error;
@@ -44,8 +75,10 @@
     }
 
     FT_Library_Version(ft, &vmajor, &vminor, &vpatch);
-    ass_msg(library, MSGL_V, "Raster: FreeType %d.%d.%d",
+    ass_msg(library, MSGL_V, "FreeType library version: %d.%d.%d",
            vmajor, vminor, vpatch);
+    ass_msg(library, MSGL_V, "FreeType headers version: %d.%d.%d",
+           FREETYPE_MAJOR, FREETYPE_MINOR, FREETYPE_PATCH);
 
     priv = calloc(1, sizeof(ASS_Renderer));
     if (!priv) {
@@ -59,10 +92,10 @@
     priv->ftlibrary = ft;
     // images_root and related stuff is zero-filled in calloc
 
-    priv->cache.font_cache = ass_font_cache_create();
-    priv->cache.bitmap_cache = ass_bitmap_cache_create();
-    priv->cache.composite_cache = ass_composite_cache_create();
-    priv->cache.outline_cache = ass_outline_cache_create();
+    priv->cache.font_cache = ass_font_cache_init(library);
+    priv->cache.bitmap_cache = ass_bitmap_cache_init(library);
+    priv->cache.composite_cache = ass_composite_cache_init(library);
+    priv->cache.glyph_cache = ass_glyph_cache_init(library);
     priv->cache.glyph_max = GLYPH_CACHE_MAX;
     priv->cache.bitmap_max_size = BITMAP_CACHE_MAX_SIZE;
 
@@ -73,19 +106,11 @@
 
     priv->settings.font_size_coeff = 1.;
 
-    priv->shaper = ass_shaper_new(0);
-    ass_shaper_info(library);
-#ifdef CONFIG_HARFBUZZ
-    priv->settings.shaper = ASS_SHAPING_COMPLEX;
-#else
-    priv->settings.shaper = ASS_SHAPING_SIMPLE;
-#endif
-
   ass_init_exit:
     if (priv)
-        ass_msg(library, MSGL_V, "Initialized");
+        ass_msg(library, MSGL_V, "Init");
     else
-        ass_msg(library, MSGL_ERR, "Initialization failed");
+        ass_msg(library, MSGL_ERR, "Init failed");
 
     return priv;
 }
@@ -106,10 +131,10 @@
 
 void ass_renderer_done(ASS_Renderer *render_priv)
 {
-    ass_cache_done(render_priv->cache.font_cache);
-    ass_cache_done(render_priv->cache.bitmap_cache);
-    ass_cache_done(render_priv->cache.composite_cache);
-    ass_cache_done(render_priv->cache.outline_cache);
+    ass_font_cache_done(render_priv->cache.font_cache);
+    ass_bitmap_cache_done(render_priv->cache.bitmap_cache);
+    ass_composite_cache_done(render_priv->cache.composite_cache);
+    ass_glyph_cache_done(render_priv->cache.glyph_cache);
 
     ass_free_images(render_priv->images_root);
     ass_free_images(render_priv->prev_images_root);
@@ -124,7 +149,6 @@
         fontconfig_done(render_priv->fontconfig_priv);
     if (render_priv->synth_priv)
         ass_synth_done(render_priv->synth_priv);
-    ass_shaper_free(render_priv->shaper);
     free(render_priv->eimg);
     free(render_priv->text_info.glyphs);
     free(render_priv->text_info.lines);
@@ -304,18 +328,18 @@
         // split up into left and right for karaoke, if needed
         if (lbrk > r[j].x0) {
             if (lbrk > r[j].x1) lbrk = r[j].x1;
-            img = my_draw_bitmap(bm->buffer + r[j].y0 * bm->stride + r[j].x0,
+            img = my_draw_bitmap(bm->buffer + r[j].y0 * bm->w + r[j].x0,
                 lbrk - r[j].x0, r[j].y1 - r[j].y0,
-                bm->stride, dst_x + r[j].x0, dst_y + r[j].y0, color);
+                bm->w, dst_x + r[j].x0, dst_y + r[j].y0, color);
             if (!img) break;
             *tail = img;
             tail = &img->next;
         }
         if (lbrk < r[j].x1) {
             if (lbrk < r[j].x0) lbrk = r[j].x0;
-            img = my_draw_bitmap(bm->buffer + r[j].y0 * bm->stride + lbrk,
+            img = my_draw_bitmap(bm->buffer + r[j].y0 * bm->w + lbrk,
                 r[j].x1 - lbrk, r[j].y1 - r[j].y0,
-                bm->stride, dst_x + lbrk, dst_y + r[j].y0, color2);
+                bm->w, dst_x + lbrk, dst_y + r[j].y0, color2);
             if (!img) break;
             *tail = img;
             tail = &img->next;
@@ -395,8 +419,8 @@
     if (brk > b_x0) {           // draw left part
         if (brk > b_x1)
             brk = b_x1;
-        img = my_draw_bitmap(bm->buffer + bm->stride * b_y0 + b_x0,
-                             brk - b_x0, b_y1 - b_y0, bm->stride,
+        img = my_draw_bitmap(bm->buffer + bm->w * b_y0 + b_x0,
+                             brk - b_x0, b_y1 - b_y0, bm->w,
                              dst_x + b_x0, dst_y + b_y0, color);
         if (!img) return tail;
         *tail = img;
@@ -405,8 +429,8 @@
     if (brk < b_x1) {           // draw right part
         if (brk < b_x0)
             brk = b_x0;
-        img = my_draw_bitmap(bm->buffer + bm->stride * b_y0 + brk,
-                             b_x1 - brk, b_y1 - b_y0, bm->stride,
+        img = my_draw_bitmap(bm->buffer + bm->w * b_y0 + brk,
+                             b_x1 - brk, b_y1 - b_y0, bm->w,
                              dst_x + brk, dst_y + b_y0, color2);
         if (!img) return tail;
         *tail = img;
@@ -492,7 +516,7 @@
     hk.by = by;
     hk.as = as;
     hk.bs = bs;
-    hv = ass_cache_get(render_priv->cache.composite_cache, &hk);
+    hv = cache_find_composite(render_priv->cache.composite_cache, &hk);
     if (hv) {
         (*last_tail)->bitmap = hv->a;
         (*tail)->bitmap = hv->b;
@@ -515,7 +539,7 @@
     // Insert bitmaps into the cache
     chv.a = (*last_tail)->bitmap;
     chv.b = (*tail)->bitmap;
-    ass_cache_put(render_priv->cache.composite_cache, &hk, &chv);
+    cache_add_composite(render_priv->cache.composite_cache, &hk, &chv);
 }
 
 static void free_list_add(ASS_Renderer *render_priv, void *object)
@@ -540,31 +564,32 @@
 static void blend_vector_clip(ASS_Renderer *render_priv,
                               ASS_Image *head)
 {
-    FT_Outline *outline;
-    Bitmap *clip_bm = NULL;
+    FT_Glyph glyph;
+    FT_BitmapGlyph clip_bm;
     ASS_Image *cur;
     ASS_Drawing *drawing = render_priv->state.clip_drawing;
-    BitmapHashKey key;
-    BitmapHashValue *val;
+    GlyphHashKey key;
+    GlyphHashValue *val;
     int error;
 
     if (!drawing)
         return;
 
     // Try to get mask from cache
+    ass_drawing_hash(drawing);
     memset(&key, 0, sizeof(key));
-    key.type = BITMAP_CLIP;
-    key.u.clip.text = drawing->text;
-    val = ass_cache_get(render_priv->cache.bitmap_cache, &key);
+    key.ch = -2;
+    key.drawing_hash = drawing->hash;
+    val = cache_find_glyph(render_priv->cache.glyph_cache, &key);
 
     if (val) {
-        clip_bm = val->bm;
+        clip_bm = (FT_BitmapGlyph) val->glyph;
     } else {
-        BitmapHashValue v;
+        GlyphHashValue v;
 
         // Not found in cache, parse and rasterize it
-        outline = ass_drawing_parse(drawing, 1);
-        if (!outline) {
+        glyph = (FT_Glyph) *ass_drawing_parse(drawing, 1);
+        if (!glyph) {
             ass_msg(render_priv->library, MSGL_WARN,
                     "Clip vector parsing failed. Skipping.");
             goto blend_vector_error;
@@ -577,27 +602,37 @@
                 .x = int_to_d6(render_priv->settings.left_margin),
                 .y = -int_to_d6(render_priv->settings.top_margin),
             };
-            FT_Outline_Translate(outline, trans.x, trans.y);
+            FT_Outline_Translate(&drawing->glyph->outline,
+                                 trans.x, trans.y);
         }
 
+        // Check glyph bounding box size
+        if (check_glyph_area(render_priv->library, glyph)) {
+            FT_Done_Glyph(glyph);
+            glyph = 0;
+            goto blend_vector_error;
+        }
+
         ass_msg(render_priv->library, MSGL_DBG2,
                 "Parsed vector clip: scales (%f, %f) string [%s]\n",
                 drawing->scale_x, drawing->scale_y, drawing->text);
 
-        clip_bm = outline_to_bitmap(render_priv->library,
-                render_priv->ftlibrary, outline, 0);
-        if (clip_bm == NULL) {
+        error = FT_Glyph_To_Bitmap(&glyph, FT_RENDER_MODE_NORMAL, 0, 1);
+        if (error) {
             ass_msg(render_priv->library, MSGL_WARN,
                 "Clip vector rasterization failed: %d. Skipping.", error);
+            FT_Done_Glyph(glyph);
+            glyph = 0;
         }
 
+blend_vector_error:
+        clip_bm = (FT_BitmapGlyph) glyph;
+
         // Add to cache
         memset(&v, 0, sizeof(v));
-        key.u.clip.text = strdup(drawing->text);
-        v.bm = clip_bm;
-        ass_cache_put(render_priv->cache.bitmap_cache, &key, &v);
+        v.glyph = glyph;
+        cache_add_glyph(render_priv->cache.glyph_cache, &key, &v);
     }
-blend_vector_error:
 
     if (!clip_bm) goto blend_vector_exit;
 
@@ -610,17 +645,17 @@
         unsigned char *abuffer, *bbuffer, *nbuffer;
 
         abuffer = cur->bitmap;
-        bbuffer = clip_bm->buffer;
+        bbuffer = clip_bm->bitmap.buffer;
         ax = cur->dst_x;
         ay = cur->dst_y;
         aw = cur->w;
         ah = cur->h;
         as = cur->stride;
         bx = clip_bm->left;
-        by = clip_bm->top;
-        bw = clip_bm->w;
-        bh = clip_bm->h;
-        bs = clip_bm->stride;
+        by = -clip_bm->top;
+        bw = clip_bm->bitmap.width;
+        bh = clip_bm->bitmap.rows;
+        bs = clip_bm->bitmap.pitch;
 
         // Calculate overlap coordinates
         left = (ax > bx) ? ax : bx;
@@ -683,8 +718,6 @@
     render_priv->state.clip_drawing = 0;
 }
 
-#define SKIP_SYMBOL(x) ((x) == 0 || (x) == '\n' || (x) == '\r')
-
 /**
  * \brief Convert TextInfo struct to ASS_Image list
  * Splits glyphs in halves when needed (for \kf karaoke).
@@ -702,107 +735,82 @@
 
     for (i = 0; i < text_info->length; ++i) {
         GlyphInfo *info = text_info->glyphs + i;
-        if (SKIP_SYMBOL(info->symbol) || !info->bm_s
+        if ((info->symbol == 0) || (info->symbol == '\n') || !info->bm_s
             || (info->shadow_x == 0 && info->shadow_y == 0) || info->skip)
             continue;
 
-        while (info) {
-            if (!info->bm_s) {
-                info = info->next;
-                continue;
-            }
+        pen_x =
+            dst_x + (info->pos.x >> 6) +
+            (int) (info->shadow_x * render_priv->border_scale);
+        pen_y =
+            dst_y + (info->pos.y >> 6) +
+            (int) (info->shadow_y * render_priv->border_scale);
+        bm = info->bm_s;
 
-            pen_x =
-                dst_x + (info->pos.x >> 6) +
-                (int) (info->shadow_x * render_priv->border_scale);
-            pen_y =
-                dst_y + (info->pos.y >> 6) +
-                (int) (info->shadow_y * render_priv->border_scale);
-            bm = info->bm_s;
+        here_tail = tail;
+        tail =
+            render_glyph(render_priv, bm, pen_x, pen_y, info->c[3], 0,
+                         1000000, tail);
+        if (last_tail && tail != here_tail && ((info->c[3] & 0xff) > 0))
+            render_overlap(render_priv, last_tail, here_tail);
 
-            here_tail = tail;
-            tail =
-                render_glyph(render_priv, bm, pen_x, pen_y, info->c[3], 0,
-                        1000000, tail);
-
-            if (last_tail && tail != here_tail && ((info->c[3] & 0xff) > 0))
-                render_overlap(render_priv, last_tail, here_tail);
-            last_tail = here_tail;
-
-            info = info->next;
-        }
+        last_tail = here_tail;
     }
 
     last_tail = 0;
     for (i = 0; i < text_info->length; ++i) {
         GlyphInfo *info = text_info->glyphs + i;
-        if (SKIP_SYMBOL(info->symbol) || !info->bm_o
+        if ((info->symbol == 0) || (info->symbol == '\n') || !info->bm_o
             || info->skip)
             continue;
 
-        while (info) {
-            if (!info->bm_o) {
-                info = info->next;
-                continue;
-            }
+        pen_x = dst_x + (info->pos.x >> 6);
+        pen_y = dst_y + (info->pos.y >> 6);
+        bm = info->bm_o;
 
-            pen_x = dst_x + (info->pos.x >> 6);
-            pen_y = dst_y + (info->pos.y >> 6);
-            bm = info->bm_o;
+        if ((info->effect_type == EF_KARAOKE_KO)
+            && (info->effect_timing <= (info->bbox.xMax >> 6))) {
+            // do nothing
+        } else {
+            here_tail = tail;
+            tail =
+                render_glyph(render_priv, bm, pen_x, pen_y, info->c[2],
+                             0, 1000000, tail);
+            if (last_tail && tail != here_tail && ((info->c[2] & 0xff) > 0))
+                render_overlap(render_priv, last_tail, here_tail);
 
-            if ((info->effect_type == EF_KARAOKE_KO)
-                    && (info->effect_timing <= (info->bbox.xMax >> 6))) {
-                // do nothing
-            } else {
-                here_tail = tail;
-                tail =
-                    render_glyph(render_priv, bm, pen_x, pen_y, info->c[2],
-                            0, 1000000, tail);
-                if (last_tail && tail != here_tail && ((info->c[2] & 0xff) > 0))
-                    render_overlap(render_priv, last_tail, here_tail);
-
-                last_tail = here_tail;
-            }
-            info = info->next;
+            last_tail = here_tail;
         }
     }
 
     for (i = 0; i < text_info->length; ++i) {
         GlyphInfo *info = text_info->glyphs + i;
-        if (SKIP_SYMBOL(info->symbol) || !info->bm
+        if ((info->symbol == 0) || (info->symbol == '\n') || !info->bm
             || info->skip)
             continue;
 
-        while (info) {
-            if (!info->bm) {
-                info = info->next;
-                continue;
-            }
+        pen_x = dst_x + (info->pos.x >> 6);
+        pen_y = dst_y + (info->pos.y >> 6);
+        bm = info->bm;
 
-            pen_x = dst_x + (info->pos.x >> 6);
-            pen_y = dst_y + (info->pos.y >> 6);
-            bm = info->bm;
-
-            if ((info->effect_type == EF_KARAOKE)
-                    || (info->effect_type == EF_KARAOKE_KO)) {
-                if (info->effect_timing > (info->bbox.xMax >> 6))
-                    tail =
-                        render_glyph(render_priv, bm, pen_x, pen_y,
-                                info->c[0], 0, 1000000, tail);
-                else
-                    tail =
-                        render_glyph(render_priv, bm, pen_x, pen_y,
-                                info->c[1], 0, 1000000, tail);
-            } else if (info->effect_type == EF_KARAOKE_KF) {
+        if ((info->effect_type == EF_KARAOKE)
+            || (info->effect_type == EF_KARAOKE_KO)) {
+            if (info->effect_timing > (info->bbox.xMax >> 6))
                 tail =
-                    render_glyph(render_priv, bm, pen_x, pen_y, info->c[0],
-                            info->c[1], info->effect_timing, tail);
-            } else
+                    render_glyph(render_priv, bm, pen_x, pen_y,
+                                 info->c[0], 0, 1000000, tail);
+            else
                 tail =
-                    render_glyph(render_priv, bm, pen_x, pen_y, info->c[0],
-                            0, 1000000, tail);
-            info = info->next;
-        }
+                    render_glyph(render_priv, bm, pen_x, pen_y,
+                                 info->c[1], 0, 1000000, tail);
+        } else if (info->effect_type == EF_KARAOKE_KF) {
+            tail =
+                render_glyph(render_priv, bm, pen_x, pen_y, info->c[0],
+                             info->c[1], info->effect_timing, tail);
+        } else
+            tail =
+                render_glyph(render_priv, bm, pen_x, pen_y, info->c[0],
+                             0, 1000000, tail);
     }
 
     *tail = 0;
@@ -811,27 +819,23 @@
     return head;
 }
 
-static void compute_string_bbox(TextInfo *text, DBBox *bbox)
+static void compute_string_bbox(TextInfo *info, DBBox *bbox)
 {
     int i;
 
-    if (text->length > 0) {
+    if (info->length > 0) {
         bbox->xMin = 32000;
         bbox->xMax = -32000;
-        bbox->yMin = -1 * text->lines[0].asc + d6_to_double(text->glyphs[0].pos.y);
-        bbox->yMax = text->height - text->lines[0].asc +
-                     d6_to_double(text->glyphs[0].pos.y);
+        bbox->yMin = -1 * info->lines[0].asc + d6_to_double(info->glyphs[0].pos.y);
+        bbox->yMax = info->height - info->lines[0].asc +
+                     d6_to_double(info->glyphs[0].pos.y);
 
-        for (i = 0; i < text->length; ++i) {
-            GlyphInfo *info = text->glyphs + i;
-            if (info->skip) continue;
-            while (info) {
-                double s = d6_to_double(info->pos.x);
-                double e = s + d6_to_double(info->advance.x);
-                bbox->xMin = FFMIN(bbox->xMin, s);
-                bbox->xMax = FFMAX(bbox->xMax, e);
-                info = info->next;
-            }
+        for (i = 0; i < info->length; ++i) {
+            if (info->glyphs[i].skip) continue;
+            double s = d6_to_double(info->glyphs[i].pos.x);
+            double e = s + d6_to_double(info->glyphs[i].advance.x);
+            bbox->xMin = FFMIN(bbox->xMin, s);
+            bbox->xMax = FFMAX(bbox->xMax, e);
         }
     } else
         bbox->xMin = bbox->xMax = bbox->yMin = bbox->yMax = 0.;
@@ -873,7 +877,6 @@
     render_priv->state.frz = M_PI * render_priv->state.style->Angle / 180.;
     render_priv->state.fax = render_priv->state.fay = 0.;
     render_priv->state.wrap_style = render_priv->track->WrapStyle;
-    render_priv->state.font_encoding = render_priv->state.style->Encoding;
 }
 
 /**
@@ -906,10 +909,10 @@
     render_priv->state.effect_type = EF_NONE;
     render_priv->state.effect_timing = 0;
     render_priv->state.effect_skip_timing = 0;
-    render_priv->state.bm_run_id = 0;
     ass_drawing_free(render_priv->state.drawing);
-    render_priv->state.drawing = ass_drawing_new(render_priv->library,
-            render_priv->ftlibrary);
+    render_priv->state.drawing = ass_drawing_new(render_priv->fontconfig_priv,
+                                                 render_priv->state.font,
+                                                 render_priv->ftlibrary);
 
     apply_transition_effects(render_priv, event);
 }
@@ -927,18 +930,30 @@
  * Replace the outline of a glyph by a contour which makes up a simple
  * opaque rectangle.
  */
-static void draw_opaque_box(ASS_Renderer *render_priv, int asc, int desc,
-                            FT_Outline *ol, FT_Vector advance, int sx, int sy)
+static void draw_opaque_box(ASS_Renderer *render_priv, uint32_t ch,
+                            FT_Glyph glyph, int sx, int sy)
 {
+    int asc = 0, desc = 0;
     int i;
-    int adv = advance.x;
+    int adv = d16_to_d6(glyph->advance.x);
     double scale_y = render_priv->state.scale_y;
     double scale_x = render_priv->state.scale_x;
+    FT_OutlineGlyph og = (FT_OutlineGlyph) glyph;
+    FT_Outline *ol;
 
     // to avoid gaps
     sx = FFMAX(64, sx);
     sy = FFMAX(64, sy);
 
+    if (ch == -1) {
+        asc = render_priv->state.drawing->asc;
+        desc = render_priv->state.drawing->desc;
+    } else {
+        ass_font_get_asc_desc(render_priv->state.font, ch, &asc, &desc);
+        asc  *= scale_y;
+        desc *= scale_y;
+    }
+
     // Emulate the WTFish behavior of VSFilter, i.e. double-scale
     // the sizes of the opaque box.
     adv += double_to_d6(render_priv->state.hspacing * render_priv->font_scale
@@ -956,8 +971,10 @@
         { .x = -sx,         .y = -desc - sy },
     };
 
-    FT_Outline_New(render_priv->ftlibrary, 4, 1, ol);
+    FT_Outline_Done(render_priv->ftlibrary, &og->outline);
+    FT_Outline_New(render_priv->ftlibrary, 4, 1, &og->outline);
 
+    ol = &og->outline;
     ol->n_points = ol->n_contours = 0;
     for (i = 0; i < 4; i++) {
         ol->points[ol->n_points] = points[i];
@@ -970,53 +987,40 @@
  * Stroke an outline glyph in x/y direction.  Applies various fixups to get
  * around limitations of the FreeType stroker.
  */
-static void stroke_outline(ASS_Renderer *render_priv, FT_Outline *outline,
-                           int sx, int sy)
+static void stroke_outline_glyph(ASS_Renderer *render_priv,
+                                 FT_OutlineGlyph *glyph, int sx, int sy)
 {
     if (sx <= 0 && sy <= 0)
         return;
 
-    fix_freetype_stroker(outline, sx, sy);
+    fix_freetype_stroker(*glyph, sx, sy);
 
     // Borders are equal; use the regular stroker
     if (sx == sy && render_priv->state.stroker) {
         int error;
-        unsigned n_points, n_contours;
-
-        FT_StrokerBorder border = FT_Outline_GetOutsideBorder(outline);
-        error = FT_Stroker_ParseOutline(render_priv->state.stroker, outline, 0);
-        if (error) {
+        error = FT_Glyph_StrokeBorder((FT_Glyph *) glyph,
+                                      render_priv->state.stroker, 0, 1);
+        if (error)
             ass_msg(render_priv->library, MSGL_WARN,
-                    "FT_Stroker_ParseOutline failed, error: %d", error);
-        }
-        error = FT_Stroker_GetBorderCounts(render_priv->state.stroker, border,
-                &n_points, &n_contours);
-        if (error) {
-            ass_msg(render_priv->library, MSGL_WARN,
-                    "FT_Stroker_GetBorderCounts failed, error: %d", error);
-        }
-        FT_Outline_Done(render_priv->ftlibrary, outline);
-        FT_Outline_New(render_priv->ftlibrary, n_points, n_contours, outline);
-        outline->n_points = outline->n_contours = 0;
-        FT_Stroker_ExportBorder(render_priv->state.stroker, border, outline);
+                    "FT_Glyph_Stroke error: %d", error);
 
     // "Stroke" with the outline emboldener in two passes.
     // The outlines look uglier, but the emboldening never adds any points
     } else {
         int i;
+        FT_Outline *ol = &(*glyph)->outline;
         FT_Outline nol;
+        FT_Outline_New(render_priv->ftlibrary, ol->n_points,
+                       ol->n_contours, &nol);
+        FT_Outline_Copy(ol, &nol);
 
-        FT_Outline_New(render_priv->ftlibrary, outline->n_points,
-                       outline->n_contours, &nol);
-        FT_Outline_Copy(outline, &nol);
-
-        FT_Outline_Embolden(outline, sx * 2);
-        FT_Outline_Translate(outline, -sx, -sx);
+        FT_Outline_Embolden(ol, sx * 2);
+        FT_Outline_Translate(ol, -sx, -sx);
         FT_Outline_Embolden(&nol, sy * 2);
         FT_Outline_Translate(&nol, -sy, -sy);
 
-        for (i = 0; i < outline->n_points; i++)
-            outline->points[i].y = nol.points[i].y;
+        for (i = 0; i < ol->n_points; i++)
+            ol->points[i].y = nol.points[i].y;
 
         FT_Outline_Done(render_priv->ftlibrary, &nol);
     }
@@ -1026,41 +1030,37 @@
  * \brief Prepare glyph hash
  */
 static void
-fill_glyph_hash(ASS_Renderer *priv, OutlineHashKey *outline_key,
-                GlyphInfo *info)
+fill_glyph_hash(ASS_Renderer *priv, GlyphHashKey *key,
+                ASS_Drawing *drawing, uint32_t ch)
 {
-    if (info->drawing) {
-        DrawingHashKey *key = &outline_key->u.drawing;
-        outline_key->type = OUTLINE_DRAWING;
-        key->scale_x = double_to_d16(info->scale_x);
-        key->scale_y = double_to_d16(info->scale_y);
-        key->outline.x = double_to_d16(info->border_x);
-        key->outline.y = double_to_d16(info->border_y);
+    if (drawing->hash) {
+        key->scale_x = double_to_d16(priv->state.scale_x);
+        key->scale_y = double_to_d16(priv->state.scale_y);
+        key->outline.x = priv->state.border_x * 0xFFFF;
+        key->outline.y = priv->state.border_y * 0xFFFF;
         key->border_style = priv->state.style->BorderStyle;
-        key->hash = info->drawing->hash;
-        key->text = info->drawing->text;
-        key->pbo = info->drawing->pbo;
-        key->scale = info->drawing->scale;
+        key->drawing_hash = drawing->hash;
+        // not very clean, but works
+        key->size = drawing->scale;
+        key->ch = -1;
     } else {
-        GlyphHashKey *key = &outline_key->u.glyph;
-        outline_key->type = OUTLINE_GLYPH;
-        key->font = info->font;
-        key->size = info->font_size;
-        key->face_index = info->face_index;
-        key->glyph_index = info->glyph_index;
-        key->bold = info->bold;
-        key->italic = info->italic;
-        key->scale_x = double_to_d16(info->scale_x);
-        key->scale_y = double_to_d16(info->scale_y);
-        key->outline.x = double_to_d16(info->border_x);
-        key->outline.y = double_to_d16(info->border_y);
-        key->flags = info->flags;
+        key->font = priv->state.font;
+        key->size = priv->state.font_size;
+        key->ch = ch;
+        key->bold = priv->state.bold;
+        key->italic = priv->state.italic;
+        key->scale_x = double_to_d16(priv->state.scale_x);
+        key->scale_y = double_to_d16(priv->state.scale_y);
+        key->outline.x = priv->state.border_x * 0xFFFF;
+        key->outline.y = priv->state.border_y * 0xFFFF;
+        key->flags = priv->state.flags;
         key->border_style = priv->state.style->BorderStyle;
     }
 }
 
 /**
  * \brief Get normal and outline (border) glyphs
+ * \param symbol ucs4 char
  * \param info out: struct filled with extracted data
  * Tries to get both glyphs from cache.
  * If they can't be found, gets a glyph from font face, generates outline with FT_Stroker,
@@ -1068,101 +1068,80 @@
  * The glyphs are returned in info->glyph and info->outline_glyph
  */
 static void
-get_outline_glyph(ASS_Renderer *priv, GlyphInfo *info)
+get_outline_glyph(ASS_Renderer *render_priv, int symbol, GlyphInfo *info,
+                  ASS_Drawing *drawing)
 {
-    OutlineHashValue *val;
-    OutlineHashKey key;
+    GlyphHashValue *val;
+    GlyphHashKey key;
 
-    memset(&info->hash_key, 0, sizeof(key));
+    memset(&key, 0, sizeof(key));
+    memset(info, 0, sizeof(GlyphInfo));
 
-    fill_glyph_hash(priv, &key, info);
-    val = ass_cache_get(priv->cache.outline_cache, &key);
-
-    if (!val) {
-        OutlineHashValue v;
-        memset(&v, 0, sizeof(v));
-
-        if (info->drawing) {
-            ASS_Drawing *drawing = info->drawing;
-            ass_drawing_hash(drawing);
+    fill_glyph_hash(render_priv, &key, drawing, symbol);
+    val = cache_find_glyph(render_priv->cache.glyph_cache, &key);
+    if (val) {
+        info->glyph = val->glyph;
+        info->outline_glyph = val->outline_glyph;
+        info->bbox = val->bbox_scaled;
+        info->advance.x = val->advance.x;
+        info->advance.y = val->advance.y;
+        if (drawing->hash) {
+            drawing->asc = val->asc;
+            drawing->desc = val->desc;
+        }
+    } else {
+        GlyphHashValue v;
+        if (drawing->hash) {
             if(!ass_drawing_parse(drawing, 0))
                 return;
-            outline_copy(priv->ftlibrary, &drawing->outline,
-                    &v.outline);
-            v.advance.x = drawing->advance.x;
-            v.advance.y = drawing->advance.y;
-            v.asc = drawing->asc;
-            v.desc = drawing->desc;
-            key.u.drawing.text = strdup(drawing->text);
+            info->glyph = (FT_Glyph) drawing->glyph;
         } else {
-            ass_face_set_size(info->font->faces[info->face_index],
-                    info->font_size);
-            ass_font_set_transform(info->font, info->scale_x,
-                    info->scale_y, NULL);
-            FT_Glyph glyph =
-                ass_font_get_glyph(priv->fontconfig_priv, info->font,
-                        info->symbol, info->face_index, info->glyph_index,
-                        priv->settings.hinting, info->flags);
-            if (glyph != NULL) {
-                outline_copy(priv->ftlibrary,
-                        &((FT_OutlineGlyph)glyph)->outline, &v.outline);
-                if (priv->settings.shaper == ASS_SHAPING_SIMPLE) {
-                    v.advance.x = d16_to_d6(glyph->advance.x);
-                    v.advance.y = d16_to_d6(glyph->advance.y);
-                }
-                FT_Done_Glyph(glyph);
-                ass_font_get_asc_desc(info->font, info->symbol,
-                        &v.asc, &v.desc);
-                v.asc  *= info->scale_y;
-                v.desc *= info->scale_y;
-            }
+            info->glyph =
+                ass_font_get_glyph(render_priv->fontconfig_priv,
+                                   render_priv->state.font, symbol,
+                                   render_priv->settings.hinting,
+                                   render_priv->state.flags);
         }
-
-        if (!v.outline)
+        if (!info->glyph)
             return;
 
-        FT_Outline_Get_CBox(v.outline, &v.bbox_scaled);
+        info->advance.x = d16_to_d6(info->glyph->advance.x);
+        info->advance.y = d16_to_d6(info->glyph->advance.y);
+        FT_Glyph_Get_CBox(info->glyph, FT_GLYPH_BBOX_SUBPIXELS, &info->bbox);
 
-        if (priv->state.style->BorderStyle == 3 &&
-                (info->border_x > 0 || info->border_y > 0)) {
-            FT_Vector advance;
+        if (render_priv->state.style->BorderStyle == 3 &&
+            (render_priv->state.border_x > 0||
+             render_priv->state.border_y > 0)) {
+            FT_Glyph_Copy(info->glyph, &info->outline_glyph);
+            draw_opaque_box(render_priv, symbol, info->outline_glyph,
+                            double_to_d6(render_priv->state.border_x *
+                                         render_priv->border_scale),
+                            double_to_d6(render_priv->state.border_y *
+                                         render_priv->border_scale));
+        } else if ((render_priv->state.border_x > 0
+                    || render_priv->state.border_y > 0)
+                   && key.scale_x && key.scale_y) {
 
-            v.border = calloc(1, sizeof(FT_Outline));
+            FT_Glyph_Copy(info->glyph, &info->outline_glyph);
+            stroke_outline_glyph(render_priv,
+                                 (FT_OutlineGlyph *) &info->outline_glyph,
+                                 double_to_d6(render_priv->state.border_x *
+                                              render_priv->border_scale),
+                                 double_to_d6(render_priv->state.border_y *
+                                              render_priv->border_scale));
+        }
 
-            if (priv->settings.shaper == ASS_SHAPING_SIMPLE || info->drawing)
-                advance = v.advance;
-            else
-                advance = info->advance;
-
-            draw_opaque_box(priv, v.asc, v.desc, v.border, advance,
-                    double_to_d6(info->border_x * priv->border_scale),
-                    double_to_d6(info->border_y * priv->border_scale));
-
-        } else if ((info->border_x > 0 || info->border_y > 0)
-                && double_to_d6(info->scale_x) && double_to_d6(info->scale_y)) {
-
-            outline_copy(priv->ftlibrary, v.outline, &v.border);
-            stroke_outline(priv, v.border,
-                    double_to_d6(info->border_x * priv->border_scale),
-                    double_to_d6(info->border_y * priv->border_scale));
+        memset(&v, 0, sizeof(v));
+        v.glyph = info->glyph;
+        v.outline_glyph = info->outline_glyph;
+        v.advance = info->advance;
+        v.bbox_scaled = info->bbox;
+        if (drawing->hash) {
+            v.asc = drawing->asc;
+            v.desc = drawing->desc;
         }
-
-        v.lib = priv->ftlibrary;
-        val = ass_cache_put(priv->cache.outline_cache, &key, &v);
+        cache_add_glyph(render_priv->cache.glyph_cache, &key, &v);
     }
-
-    info->hash_key.u.outline.outline = val;
-    info->outline = val->outline;
-    info->border = val->border;
-    info->bbox = val->bbox_scaled;
-    if (info->drawing || priv->settings.shaper == ASS_SHAPING_SIMPLE) {
-        info->cluster_advance.x = info->advance.x = val->advance.x;
-        info->cluster_advance.y = info->advance.y = val->advance.y;
-    }
-    info->asc = val->asc;
-    info->desc = val->desc;
-
-    ass_drawing_free(info->drawing);
 }
 
 /**
@@ -1171,7 +1150,7 @@
  * onto the screen plane.
  */
 static void
-transform_3d_points(FT_Vector shift, FT_Outline *outline, double frx, double fry,
+transform_3d_points(FT_Vector shift, FT_Glyph glyph, double frx, double fry,
                     double frz, double fax, double fay, double scale,
                     int yshift)
 {
@@ -1181,6 +1160,7 @@
     double cx = cos(frx);
     double cy = cos(fry);
     double cz = cos(frz);
+    FT_Outline *outline = &((FT_OutlineGlyph) glyph)->outline;
     FT_Vector *p = outline->points;
     double x, y, z, xx, yy, zz;
     int i, dist;
@@ -1223,19 +1203,19 @@
  * Rotates both glyphs by frx, fry and frz. Shift vector is added before rotation and subtracted after it.
  */
 static void
-transform_3d(FT_Vector shift, FT_Outline *outline, FT_Outline *border,
+transform_3d(FT_Vector shift, FT_Glyph *glyph, FT_Glyph *glyph2,
              double frx, double fry, double frz, double fax, double fay,
              double scale, int yshift)
 {
     frx = -frx;
     frz = -frz;
     if (frx != 0. || fry != 0. || frz != 0. || fax != 0. || fay != 0.) {
-        if (outline)
-            transform_3d_points(shift, outline, frx, fry, frz,
+        if (glyph && *glyph)
+            transform_3d_points(shift, *glyph, frx, fry, frz,
                                 fax, fay, scale, yshift);
 
-        if (border)
-            transform_3d_points(shift, border, frx, fry, frz,
+        if (glyph2 && *glyph2)
+            transform_3d_points(shift, *glyph2, frx, fry, frz,
                                 fax, fay, scale, yshift);
     }
 }
@@ -1252,80 +1232,81 @@
 get_bitmap_glyph(ASS_Renderer *render_priv, GlyphInfo *info)
 {
     BitmapHashValue *val;
-    OutlineBitmapHashKey *key = &info->hash_key.u.outline;
+    BitmapHashKey *key = &info->hash_key;
 
-    if (!info->outline || info->symbol == '\n' || info->symbol == 0 || info->skip)
-        return;
+    val = cache_find_bitmap(render_priv->cache.bitmap_cache, key);
 
-    val = ass_cache_get(render_priv->cache.bitmap_cache, &info->hash_key);
-
-    if (!val) {
+    if (val) {
+        info->bm = val->bm;
+        info->bm_o = val->bm_o;
+        info->bm_s = val->bm_s;
+    } else {
         FT_Vector shift;
         BitmapHashValue hash_val;
         int error;
         double fax_scaled, fay_scaled;
-        FT_Outline *outline, *border;
-        double scale_x = render_priv->font_scale_x;
+        info->bm = info->bm_o = info->bm_s = 0;
+        if (info->glyph && info->symbol != '\n' && info->symbol != 0
+            && !info->skip) {
+            FT_Glyph glyph;
+            FT_Glyph outline;
+            double scale_x = render_priv->font_scale_x;
 
-        hash_val.bm = hash_val.bm_o = hash_val.bm_s = 0;
+            FT_Glyph_Copy(info->glyph, &glyph);
+            FT_Glyph_Copy(info->outline_glyph, &outline);
+            // calculating rotation shift vector (from rotation origin to the glyph basepoint)
+            shift.x = key->shift_x;
+            shift.y = key->shift_y;
+            fax_scaled = info->fax *
+                         render_priv->state.scale_x;
+            fay_scaled = info->fay * render_priv->state.scale_y;
+            // apply rotation
+            transform_3d(shift, &glyph, &outline,
+                         info->frx, info->fry, info->frz, fax_scaled,
+                         fay_scaled, render_priv->font_scale, info->asc);
 
-        outline_copy(render_priv->ftlibrary, info->outline, &outline);
-        outline_copy(render_priv->ftlibrary, info->border, &border);
+            // PAR correction scaling
+            FT_Matrix m = { double_to_d16(scale_x), 0,
+                            0, double_to_d16(1.0) };
 
-        // calculating rotation shift vector (from rotation origin to the glyph basepoint)
-        shift.x = key->shift_x;
-        shift.y = key->shift_y;
-        fax_scaled = info->fax * render_priv->state.scale_x;
-        fay_scaled = info->fay * render_priv->state.scale_y;
+            // subpixel shift
+            if (glyph) {
+                FT_Outline *outl = &((FT_OutlineGlyph) glyph)->outline;
+                if (scale_x != 1.0)
+                    FT_Outline_Transform(outl, &m);
+                FT_Outline_Translate(outl, key->advance.x, -key->advance.y);
+            }
+            if (outline) {
+                FT_Outline *outl = &((FT_OutlineGlyph) outline)->outline;
+                if (scale_x != 1.0)
+                    FT_Outline_Transform(outl, &m);
+                FT_Outline_Translate(outl, key->advance.x, -key->advance.y);
+            }
+            // render glyph
+            error = glyph_to_bitmap(render_priv->library,
+                                    render_priv->synth_priv,
+                                    glyph, outline,
+                                    &info->bm, &info->bm_o,
+                                    &info->bm_s, info->be,
+                                    info->blur * render_priv->border_scale,
+                                    key->shadow_offset, key->border_style);
+            if (error)
+                info->symbol = 0;
 
-        // apply rotation
-        transform_3d(shift, outline, border,
-                info->frx, info->fry, info->frz, fax_scaled,
-                fay_scaled, render_priv->font_scale, info->asc);
+            // add bitmaps to cache
+            hash_val.bm_o = info->bm_o;
+            hash_val.bm = info->bm;
+            hash_val.bm_s = info->bm_s;
+            cache_add_bitmap(render_priv->cache.bitmap_cache, key, &hash_val);
 
-        // PAR correction scaling
-        FT_Matrix m = { double_to_d16(scale_x), 0,
-            0, double_to_d16(1.0) };
-
-        // subpixel shift
-        if (outline) {
-            if (scale_x != 1.0)
-                FT_Outline_Transform(outline, &m);
-            FT_Outline_Translate(outline, key->advance.x, -key->advance.y);
+            FT_Done_Glyph(glyph);
+            FT_Done_Glyph(outline);
         }
-        if (border) {
-            if (scale_x != 1.0)
-                FT_Outline_Transform(border, &m);
-            FT_Outline_Translate(border, key->advance.x, -key->advance.y);
-        }
-
-        // render glyph
-        error = outline_to_bitmap3(render_priv->library,
-                render_priv->synth_priv,
-                render_priv->ftlibrary,
-                outline, border,
-                &hash_val.bm, &hash_val.bm_o,
-                &hash_val.bm_s, info->be,
-                info->blur * render_priv->border_scale,
-                key->shadow_offset,
-                render_priv->state.style->BorderStyle);
-        if (error)
-            info->symbol = 0;
-
-        val = ass_cache_put(render_priv->cache.bitmap_cache, &info->hash_key,
-                &hash_val);
-
-        outline_free(render_priv->ftlibrary, outline);
-        outline_free(render_priv->ftlibrary, border);
     }
 
-    info->bm = val->bm;
-    info->bm_o = val->bm_o;
-    info->bm_s = val->bm_s;
-
     // VSFilter compatibility: invisible fill and no border?
     // In this case no shadow is supposed to be rendered.
-    if (!info->border && (info->c[0] & 0xFF) == 0xFF)
+    if (!info->outline_glyph && (info->c[0] & 0xFF) == 0xFF)
         info->bm_s = 0;
 }
 
@@ -1453,7 +1434,6 @@
     double pen_shift_x;
     double pen_shift_y;
     int cur_line;
-    int run_offset;
     TextInfo *text_info = &render_priv->text_info;
 
     last_space = -1;
@@ -1494,13 +1474,12 @@
                                            sizeof(LineInfo) *
                                            text_info->max_lines);
             }
-            if (lead < text_info->length) {
+            if (lead < text_info->length)
                 text_info->glyphs[lead].linebreak = break_type;
-                last_space = -1;
-                s1 = text_info->glyphs + lead;
-                s_offset = d6_to_double(s1->bbox.xMin + s1->pos.x);
-                text_info->n_lines++;
-            }
+            last_space = -1;
+            s1 = text_info->glyphs + lead;
+            s_offset = d6_to_double(s1->bbox.xMin + s1->pos.x);
+            text_info->n_lines++;
         }
     }
 #define DIFF(x,y) (((x) < (y)) ? (y - x) : (x - y))
@@ -1564,7 +1543,6 @@
     pen_shift_x = 0.;
     pen_shift_y = 0.;
     cur_line = 1;
-    run_offset = 0;
 
     i = 0;
     cur = text_info->glyphs + i;
@@ -1580,31 +1558,86 @@
             double height =
                 text_info->lines[cur_line - 1].desc +
                 text_info->lines[cur_line].asc;
-            text_info->lines[cur_line - 1].len = i -
-                text_info->lines[cur_line - 1].offset;
-            text_info->lines[cur_line].offset = i;
             cur_line++;
-            run_offset++;
             pen_shift_x = d6_to_double(-cur->pos.x);
             pen_shift_y += height + render_priv->settings.line_spacing;
             ass_msg(render_priv->library, MSGL_DBG2,
                    "shifting from %d to %d by (%f, %f)", i,
                    text_info->length - 1, pen_shift_x, pen_shift_y);
         }
-        cur->bm_run_id += run_offset;
         cur->pos.x += double_to_d6(pen_shift_x);
         cur->pos.y += double_to_d6(pen_shift_y);
     }
-    text_info->lines[cur_line - 1].len =
-        text_info->length - text_info->lines[cur_line - 1].offset;
+}
 
-#if 0
-    // print line info
-    for (i = 0; i < text_info->n_lines; i++) {
-        printf("line %d offset %d length %d\n", i, text_info->lines[i].offset,
-                text_info->lines[i].len);
+/**
+ * \brief determine karaoke effects
+ * Karaoke effects cannot be calculated during parse stage (get_next_char()),
+ * so they are done in a separate step.
+ * Parse stage: when karaoke style override is found, its parameters are stored in the next glyph's
+ * (the first glyph of the karaoke word)'s effect_type and effect_timing.
+ * This function:
+ * 1. sets effect_type for all glyphs in the word (_karaoke_ word)
+ * 2. sets effect_timing for all glyphs to x coordinate of the border line between the left and right karaoke parts
+ * (left part is filled with PrimaryColour, right one - with SecondaryColour).
+ */
+static void process_karaoke_effects(ASS_Renderer *render_priv)
+{
+    GlyphInfo *cur, *cur2;
+    GlyphInfo *s1, *e1;      // start and end of the current word
+    GlyphInfo *s2;           // start of the next word
+    int i;
+    int timing;                 // current timing
+    int tm_start, tm_end;       // timings at start and end of the current word
+    int tm_current;
+    double dt;
+    int x;
+    int x_start, x_end;
+
+    tm_current = render_priv->time - render_priv->state.event->Start;
+    timing = 0;
+    s1 = s2 = 0;
+    for (i = 0; i <= render_priv->text_info.length; ++i) {
+        cur = render_priv->text_info.glyphs + i;
+        if ((i == render_priv->text_info.length)
+            || (cur->effect_type != EF_NONE)) {
+            s1 = s2;
+            s2 = cur;
+            if (s1) {
+                e1 = s2 - 1;
+                tm_start = timing + s1->effect_skip_timing;
+                tm_end = tm_start + s1->effect_timing;
+                timing = tm_end;
+                x_start = 1000000;
+                x_end = -1000000;
+                for (cur2 = s1; cur2 <= e1; ++cur2) {
+                    x_start = FFMIN(x_start, d6_to_int(cur2->bbox.xMin + cur2->pos.x));
+                    x_end = FFMAX(x_end, d6_to_int(cur2->bbox.xMax + cur2->pos.x));
+                }
+
+                dt = (tm_current - tm_start);
+                if ((s1->effect_type == EF_KARAOKE)
+                    || (s1->effect_type == EF_KARAOKE_KO)) {
+                    if (dt > 0)
+                        x = x_end + 1;
+                    else
+                        x = x_start;
+                } else if (s1->effect_type == EF_KARAOKE_KF) {
+                    dt /= (tm_end - tm_start);
+                    x = x_start + (x_end - x_start) * dt;
+                } else {
+                    ass_msg(render_priv->library, MSGL_ERR,
+                            "Unknown effect type");
+                    continue;
+                }
+
+                for (cur2 = s1; cur2 <= e1; ++cur2) {
+                    cur2->effect_type = s1->effect_type;
+                    cur2->effect_timing = x - d6_to_int(cur2->pos.x);
+                }
+            }
+        }
     }
-#endif
 }
 
 /**
@@ -1647,22 +1680,38 @@
  * Prepare bitmap hash key of a glyph
  */
 static void
-fill_bitmap_hash(ASS_Renderer *priv, GlyphInfo *info,
-                 OutlineBitmapHashKey *hash_key)
+fill_bitmap_hash(ASS_Renderer *priv, BitmapHashKey *hash_key,
+                 ASS_Drawing *drawing, FT_Vector pen, uint32_t code)
 {
-    hash_key->frx = rot_key(info->frx);
-    hash_key->fry = rot_key(info->fry);
-    hash_key->frz = rot_key(info->frz);
-    hash_key->fax = double_to_d16(info->fax);
-    hash_key->fay = double_to_d16(info->fay);
-    hash_key->be = info->be;
-    hash_key->blur = info->blur;
+    if (!drawing->hash) {
+        hash_key->font = priv->state.font;
+        hash_key->size = priv->state.font_size;
+        hash_key->bold = priv->state.bold;
+        hash_key->italic = priv->state.italic;
+    } else {
+        hash_key->drawing_hash = drawing->hash;
+        hash_key->size = drawing->scale;
+    }
+    hash_key->ch = code;
+    hash_key->outline.x = double_to_d16(priv->state.border_x);
+    hash_key->outline.y = double_to_d16(priv->state.border_y);
+    hash_key->scale_x = double_to_d16(priv->state.scale_x);
+    hash_key->scale_y = double_to_d16(priv->state.scale_y);
+    hash_key->frx = rot_key(priv->state.frx);
+    hash_key->fry = rot_key(priv->state.fry);
+    hash_key->frz = rot_key(priv->state.frz);
+    hash_key->fax = double_to_d16(priv->state.fax);
+    hash_key->fay = double_to_d16(priv->state.fay);
+    hash_key->be = priv->state.be;
+    hash_key->blur = priv->state.blur;
+    hash_key->border_style = priv->state.style->BorderStyle;
     hash_key->shadow_offset.x = double_to_d6(
-            info->shadow_x * priv->border_scale -
-            (int) (info->shadow_x * priv->border_scale));
+            priv->state.shadow_x * priv->border_scale -
+            (int) (priv->state.shadow_x * priv->border_scale));
     hash_key->shadow_offset.y = double_to_d6(
-            info->shadow_y * priv->border_scale -
-            (int) (info->shadow_y * priv->border_scale));
+            priv->state.shadow_y * priv->border_scale -
+            (int) (priv->state.shadow_y * priv->border_scale));
+    hash_key->flags = priv->state.flags;
 }
 
 /**
@@ -1685,6 +1734,7 @@
     int MarginL, MarginR, MarginV;
     int last_break;
     int alignment, halign, valign;
+    int kern = render_priv->track->Kerning;
     double device_x = 0;
     double device_y = 0;
     TextInfo *text_info = &render_priv->text_info;
@@ -1704,9 +1754,11 @@
 
     drawing = render_priv->state.drawing;
     text_info->length = 0;
+    pen.x = 0;
+    pen.y = 0;
+    previous = 0;
     num_glyphs = 0;
     p = event->Text;
-
     // Event parsing.
     while (1) {
         // get next char, executing style override
@@ -1717,26 +1769,15 @@
                 ass_drawing_add_char(drawing, (char) code);
         } while (code && render_priv->state.drawing_mode);      // skip everything in drawing mode
 
-        if (text_info->length >= text_info->max_glyphs) {
-            // Raise maximum number of glyphs
-            text_info->max_glyphs *= 2;
-            text_info->glyphs = glyphs =
-                realloc(text_info->glyphs,
-                        sizeof(GlyphInfo) * text_info->max_glyphs);
-        }
-
-        // Clear current GlyphInfo
-        memset(&glyphs[text_info->length], 0, sizeof(GlyphInfo));
-
         // Parse drawing
         if (drawing->i) {
             drawing->scale_x = render_priv->state.scale_x *
                                      render_priv->font_scale;
             drawing->scale_y = render_priv->state.scale_y *
                                      render_priv->font_scale;
+            ass_drawing_hash(drawing);
             p--;
-            code = 0xfffc; // object replacement character
-            glyphs[text_info->length].drawing = drawing;
+            code = -1;
         }
 
         // face could have been changed in get_next_char
@@ -1748,9 +1789,61 @@
         if (code == 0)
             break;
 
-        // Fill glyph information
+        if (text_info->length >= text_info->max_glyphs) {
+            // Raise maximum number of glyphs
+            text_info->max_glyphs *= 2;
+            text_info->glyphs = glyphs =
+                realloc(text_info->glyphs,
+                        sizeof(GlyphInfo) * text_info->max_glyphs);
+        }
+
+        // Add kerning to pen
+        if (kern && previous && code && !drawing->hash) {
+            FT_Vector delta;
+            delta =
+                ass_font_get_kerning(render_priv->state.font, previous,
+                                     code);
+            pen.x += delta.x * render_priv->state.scale_x;
+            pen.y += delta.y * render_priv->state.scale_y;
+        }
+
+        ass_font_set_transform(render_priv->state.font,
+                               render_priv->state.scale_x,
+                               render_priv->state.scale_y, NULL);
+
+        get_outline_glyph(render_priv, code,
+                          glyphs + text_info->length, drawing);
+
+        // Add additional space after italic to non-italic style changes
+        if (text_info->length &&
+            glyphs[text_info->length - 1].hash_key.italic &&
+            !render_priv->state.italic) {
+            int back = text_info->length - 1;
+            GlyphInfo *og = &glyphs[back];
+            while (back && og->bbox.xMax - og->bbox.xMin == 0
+                   && og->hash_key.italic)
+                og = &glyphs[--back];
+            if (og->bbox.xMax > og->advance.x) {
+                // The FreeType oblique slants by 6/16
+                pen.x += og->bbox.yMax * 0.375;
+            }
+        }
+
+        glyphs[text_info->length].pos.x = pen.x;
+        glyphs[text_info->length].pos.y = pen.y;
+
+        pen.x += glyphs[text_info->length].advance.x;
+        pen.x += double_to_d6(render_priv->state.hspacing *
+                              render_priv->font_scale
+                              * render_priv->state.scale_x);
+        pen.y += glyphs[text_info->length].advance.y;
+        pen.y += (render_priv->state.fay * render_priv->state.scale_y) *
+                 glyphs[text_info->length].advance.x;
+
+        previous = code;
+
         glyphs[text_info->length].symbol = code;
-        glyphs[text_info->length].font = render_priv->state.font;
+        glyphs[text_info->length].linebreak = 0;
         for (i = 0; i < 4; ++i) {
             uint32_t clr = render_priv->state.c[i];
             change_alpha(&clr,
@@ -1762,108 +1855,53 @@
             render_priv->state.effect_timing;
         glyphs[text_info->length].effect_skip_timing =
             render_priv->state.effect_skip_timing;
-        glyphs[text_info->length].font_size = ensure_font_size(render_priv,
-                    render_priv->state.font_size * render_priv->font_scale);
         glyphs[text_info->length].be = render_priv->state.be;
         glyphs[text_info->length].blur = render_priv->state.blur;
         glyphs[text_info->length].shadow_x = render_priv->state.shadow_x;
         glyphs[text_info->length].shadow_y = render_priv->state.shadow_y;
-        glyphs[text_info->length].scale_x= render_priv->state.scale_x;
-        glyphs[text_info->length].scale_y = render_priv->state.scale_y;
-        glyphs[text_info->length].border_x= render_priv->state.border_x;
-        glyphs[text_info->length].border_y = render_priv->state.border_y;
-        glyphs[text_info->length].bold = render_priv->state.bold;
-        glyphs[text_info->length].italic = render_priv->state.italic;
-        glyphs[text_info->length].flags = render_priv->state.flags;
         glyphs[text_info->length].frx = render_priv->state.frx;
         glyphs[text_info->length].fry = render_priv->state.fry;
         glyphs[text_info->length].frz = render_priv->state.frz;
         glyphs[text_info->length].fax = render_priv->state.fax;
         glyphs[text_info->length].fay = render_priv->state.fay;
-        glyphs[text_info->length].bm_run_id = render_priv->state.bm_run_id;
+        if (drawing->hash) {
+            glyphs[text_info->length].asc = drawing->asc;
+            glyphs[text_info->length].desc = drawing->desc;
+        } else {
+            ass_font_get_asc_desc(render_priv->state.font, code,
+                                  &glyphs[text_info->length].asc,
+                                  &glyphs[text_info->length].desc);
 
-        if (glyphs[text_info->length].drawing) {
-            drawing = render_priv->state.drawing =
-                ass_drawing_new(render_priv->library, render_priv->ftlibrary);
+            glyphs[text_info->length].asc *= render_priv->state.scale_y;
+            glyphs[text_info->length].desc *= render_priv->state.scale_y;
         }
 
+        // fill bitmap hash
+        fill_bitmap_hash(render_priv, &glyphs[text_info->length].hash_key,
+                         drawing, pen, code);
+
         text_info->length++;
 
         render_priv->state.effect_type = EF_NONE;
         render_priv->state.effect_timing = 0;
         render_priv->state.effect_skip_timing = 0;
 
+        if (drawing->hash) {
+            ass_drawing_free(drawing);
+            drawing = render_priv->state.drawing =
+                ass_drawing_new(render_priv->fontconfig_priv,
+                    render_priv->state.font,
+                    render_priv->ftlibrary);
+        }
     }
 
+
     if (text_info->length == 0) {
         // no valid symbols in the event; this can be smth like {comment}
         free_render_context(render_priv);
         return 1;
     }
 
-    // Find shape runs and shape text
-    ass_shaper_set_base_direction(render_priv->shaper,
-            resolve_base_direction(render_priv->state.font_encoding));
-    ass_shaper_find_runs(render_priv->shaper, render_priv, glyphs,
-            text_info->length);
-    ass_shaper_shape(render_priv->shaper, text_info);
-
-    // Retrieve glyphs
-    for (i = 0; i < text_info->length; i++) {
-        GlyphInfo *info = glyphs + i;
-        while (info) {
-            get_outline_glyph(render_priv, info);
-            info = info->next;
-        }
-        info = glyphs + i;
-
-        // Add additional space after italic to non-italic style changes
-        if (i && glyphs[i - 1].italic && !info->italic) {
-            int back = i - 1;
-            GlyphInfo *og = &glyphs[back];
-            while (back && og->bbox.xMax - og->bbox.xMin == 0
-                    && og->italic)
-                og = &glyphs[--back];
-            if (og->bbox.xMax > og->cluster_advance.x)
-                og->cluster_advance.x = og->bbox.xMax;
-        }
-
-        // add horizontal letter spacing
-        info->cluster_advance.x += double_to_d6(render_priv->state.hspacing *
-                render_priv->font_scale * info->scale_x);
-
-        // add displacement for vertical shearing
-        info->cluster_advance.y += (info->fay * info->scale_y) * info->cluster_advance.x;
-
-    }
-
-    // Preliminary layout (for line wrapping)
-    previous = 0;
-    pen.x = 0;
-    pen.y = 0;
-    for (i = 0; i < text_info->length; i++) {
-        GlyphInfo *info = glyphs + i;
-        FT_Vector cluster_pen = pen;
-        while (info) {
-            info->pos.x = cluster_pen.x;
-            info->pos.y = cluster_pen.y;
-
-            cluster_pen.x += info->advance.x;
-            cluster_pen.y += info->advance.y;
-
-            // fill bitmap hash
-            info->hash_key.type = BITMAP_OUTLINE;
-            fill_bitmap_hash(render_priv, info, &info->hash_key.u.outline);
-
-            info = info->next;
-        }
-        info = glyphs + i;
-        pen.x += info->cluster_advance.x;
-        pen.y += info->cluster_advance.y;
-        previous = info->symbol;
-    }
-
-
     // depends on glyph x coordinates being monotonous, so it should be done before line wrap
     process_karaoke_effects(render_priv);
 
@@ -1879,64 +1917,40 @@
     MarginV =
         (event->MarginV) ? event->MarginV : render_priv->state.style->MarginV;
 
-    // calculate max length of a line
-    double max_text_width =
-        x2scr(render_priv, render_priv->track->PlayResX - MarginR) -
-        x2scr(render_priv, MarginL);
+    if (render_priv->state.evt_type != EVENT_HSCROLL) {
+        double max_text_width;
 
-    // wrap lines
-    if (render_priv->state.evt_type != EVENT_HSCROLL) {
+        // calculate max length of a line
+        max_text_width =
+            x2scr(render_priv,
+                  render_priv->track->PlayResX - MarginR) -
+            x2scr(render_priv, MarginL);
+
         // rearrange text in several lines
         wrap_lines_smart(render_priv, max_text_width);
-    } else {
-        // no breaking or wrapping, everything in a single line
-        text_info->lines[0].offset = 0;
-        text_info->lines[0].len = text_info->length;
-        text_info->n_lines = 1;
-        measure_text(render_priv);
-    }
 
-    // Reorder text into visual order
-    FriBidiStrIndex *cmap = ass_shaper_reorder(render_priv->shaper, text_info);
+        // align text
+        last_break = -1;
+        for (i = 1; i < text_info->length + 1; ++i) {   // (text_info->length + 1) is the end of the last line
+            if ((i == text_info->length)
+                || glyphs[i].linebreak) {
+                double width, shift = 0;
+                GlyphInfo *first_glyph =
+                    glyphs + last_break + 1;
+                GlyphInfo *last_glyph = glyphs + i - 1;
 
-    // Reposition according to the map
-    pen.x = 0;
-    pen.y = 0;
-    int lineno = 1;
-    for (i = 0; i < text_info->length; i++) {
-        GlyphInfo *info = glyphs + cmap[i];
-        if (glyphs[i].linebreak) {
-            pen.x = 0;
-            pen.y += double_to_d6(text_info->lines[lineno-1].desc);
-            pen.y += double_to_d6(text_info->lines[lineno].asc);
-            pen.y += double_to_d6(render_priv->settings.line_spacing);
-            lineno++;
-        }
-        if (info->skip) continue;
-        FT_Vector cluster_pen = pen;
-        while (info) {
-            info->pos.x = info->offset.x + cluster_pen.x;
-            info->pos.y = info->offset.y + cluster_pen.y;
-            cluster_pen.x += info->advance.x;
-            cluster_pen.y += info->advance.y;
-            info = info->next;
-        }
-        info = glyphs + cmap[i];
-        pen.x += info->cluster_advance.x;
-        pen.y += info->cluster_advance.y;
-    }
+                while (first_glyph < last_glyph && first_glyph->skip)
+                    first_glyph++;
 
-    // align lines
-    if (render_priv->state.evt_type != EVENT_HSCROLL) {
-        last_break = -1;
-        double width = 0;
-        for (i = 0; i <= text_info->length; ++i) {   // (text_info->length + 1) is the end of the last line
-            if ((i == text_info->length) || glyphs[i].linebreak) {
-                // remove letter spacing (which is included in cluster_advance)
-                if (i > 0)
-                    width -= render_priv->state.hspacing * render_priv->font_scale *
-                        glyphs[i-1].scale_x;
-                double shift = 0;
+                while ((last_glyph > first_glyph)
+                       && ((last_glyph->symbol == '\n')
+                           || (last_glyph->symbol == 0)
+                           || (last_glyph->skip)))
+                    last_glyph--;
+
+                width = d6_to_double(
+                    last_glyph->pos.x + last_glyph->advance.x -
+                    first_glyph->pos.x);
                 if (halign == HALIGN_LEFT) {    // left aligned, no action
                     shift = 0;
                 } else if (halign == HALIGN_RIGHT) {    // right aligned
@@ -1945,20 +1959,13 @@
                     shift = (max_text_width - width) / 2.0;
                 }
                 for (j = last_break + 1; j < i; ++j) {
-                    GlyphInfo *info = glyphs + j;
-                    while (info) {
-                        info->pos.x += double_to_d6(shift);
-                        info = info->next;
-                    }
+                    glyphs[j].pos.x += double_to_d6(shift);
                 }
                 last_break = i - 1;
-                width = 0;
             }
-            if (i < text_info->length && !glyphs[i].skip &&
-                    glyphs[i].symbol != '\n' && glyphs[i].symbol != 0) {
-                width += d6_to_double(glyphs[i].cluster_advance.x);
-            }
         }
+    } else {                    // render_priv->state.evt_type == EVENT_HSCROLL
+        measure_text(render_priv);
     }
 
     // determing text bounding box
@@ -2084,38 +2091,32 @@
 
         for (i = 0; i < text_info->length; ++i) {
             GlyphInfo *info = glyphs + i;
-            while (info) {
-                OutlineBitmapHashKey *key = &info->hash_key.u.outline;
 
-                if (key->frx || key->fry || key->frz || key->fax || key->fay) {
-                    key->shift_x = info->pos.x + double_to_d6(device_x - center.x);
-                    key->shift_y = -(info->pos.y + double_to_d6(device_y - center.y));
-                } else {
-                    key->shift_x = 0;
-                    key->shift_y = 0;
-                }
-                info = info->next;
+            if (info->hash_key.frx || info->hash_key.fry
+                || info->hash_key.frz || info->hash_key.fax
+                || info->hash_key.fay) {
+                info->hash_key.shift_x = info->pos.x + double_to_d6(device_x - center.x);
+                info->hash_key.shift_y =
+                    -(info->pos.y + double_to_d6(device_y - center.y));
+            } else {
+                info->hash_key.shift_x = 0;
+                info->hash_key.shift_y = 0;
             }
         }
     }
 
     // convert glyphs to bitmaps
-    int left = render_priv->settings.left_margin;
-    device_x = (device_x - left) * render_priv->font_scale_x + left;
+    device_x *= render_priv->font_scale_x;
     for (i = 0; i < text_info->length; ++i) {
-        GlyphInfo *info = glyphs + i;
-        while (info) {
-            OutlineBitmapHashKey *key = &info->hash_key.u.outline;
-            info->pos.x *= render_priv->font_scale_x;
-            key->advance.x =
-                double_to_d6(device_x - (int) device_x +
-                        d6_to_double(info->pos.x & SUBPIXEL_MASK)) & ~SUBPIXEL_ACCURACY;
-            key->advance.y =
-                double_to_d6(device_y - (int) device_y +
-                        d6_to_double(info->pos.y & SUBPIXEL_MASK)) & ~SUBPIXEL_ACCURACY;
-            get_bitmap_glyph(render_priv, info);
-            info = info->next;
-        }
+        GlyphInfo *g = glyphs + i;
+        g->pos.x *= render_priv->font_scale_x;
+        g->hash_key.advance.x =
+            double_to_d6(device_x - (int) device_x +
+            d6_to_double(g->pos.x & SUBPIXEL_MASK)) & ~SUBPIXEL_ACCURACY;
+        g->hash_key.advance.y =
+            double_to_d6(device_y - (int) device_y +
+            d6_to_double(g->pos.y & SUBPIXEL_MASK)) & ~SUBPIXEL_ACCURACY;
+        get_bitmap_glyph(render_priv, glyphs + i);
     }
 
     memset(event_images, 0, sizeof(*event_images));
@@ -2130,7 +2131,6 @@
     event_images->event = event;
     event_images->imgs = render_text(render_priv, (int) device_x, (int) device_y);
 
-    ass_shaper_cleanup(render_priv->shaper, text_info);
     free_render_context(render_priv);
 
     return 0;
@@ -2154,16 +2154,24 @@
  */
 static void check_cache_limits(ASS_Renderer *priv, CacheStore *cache)
 {
-    if (ass_cache_empty(cache->bitmap_cache, cache->bitmap_max_size)) {
-        ass_cache_empty(cache->composite_cache, 0);
+    if (cache->bitmap_cache->cache_size > cache->bitmap_max_size) {
+        ass_msg(priv->library, MSGL_V,
+                "Hitting hard bitmap cache limit (was: %ld bytes), "
+                "resetting.", (long) cache->bitmap_cache->cache_size);
+        cache->bitmap_cache = ass_bitmap_cache_reset(cache->bitmap_cache);
+        cache->composite_cache = ass_composite_cache_reset(
+            cache->composite_cache);
         ass_free_images(priv->prev_images_root);
         priv->prev_images_root = 0;
     }
-    if (ass_cache_empty(cache->outline_cache, cache->glyph_max)) {
-        ass_cache_empty(cache->bitmap_cache, 0);
-        ass_cache_empty(cache->composite_cache, 0);
-        ass_free_images(priv->prev_images_root);
-        priv->prev_images_root = 0;
+
+    if (cache->glyph_cache->count > cache->glyph_max
+        || cache->glyph_cache->cache_size > cache->bitmap_max_size) {
+        ass_msg(priv->library, MSGL_V,
+            "Hitting hard glyph cache limit (was: %d glyphs, %ld bytes), "
+            "resetting.",
+            cache->glyph_cache->count, (long) cache->glyph_cache->cache_size);
+        cache->glyph_cache = ass_glyph_cache_reset(cache->glyph_cache);
     }
 }
 
@@ -2194,7 +2202,7 @@
     render_priv->track = track;
     render_priv->time = now;
 
-    ass_lazy_track_init(render_priv->library, render_priv->track);
+    ass_lazy_track_init(render_priv);
 
     render_priv->font_scale = settings_priv->font_size_coeff *
         render_priv->orig_height / render_priv->track->PlayResY;
@@ -2205,11 +2213,6 @@
     else
         render_priv->border_scale = 1.;
 
-    ass_shaper_set_kerning(render_priv->shaper, track->Kerning);
-    if (track->Language)
-        ass_shaper_set_language(render_priv->shaper, track->Language);
-    ass_shaper_set_level(render_priv->shaper, render_priv->settings.shaper);
-
     // PAR correction
     render_priv->font_scale_x = render_priv->settings.aspect /
                                 render_priv->settings.storage_aspect;
Index: libass/ass_render.h
===================================================================
--- libass/ass_render.h	(revision 34728)
+++ libass/ass_render.h	(working copy)
@@ -27,9 +27,6 @@
 #include FT_GLYPH_H
 #include FT_SYNTHESIS_H
 
-// XXX: fix the inclusion mess so we can avoid doing this here
-typedef struct ass_shaper ASS_Shaper;
-
 #include "ass.h"
 #include "ass_font.h"
 #include "ass_bitmap.h"
@@ -76,7 +73,6 @@
     double aspect;              // frame aspect ratio, d_width / d_height.
     double storage_aspect;      // pixel ratio of the source image
     ASS_Hinting hinting;
-    ASS_ShapingLevel shaper;
 
     char *default_font;
     char *default_family;
@@ -100,26 +96,19 @@
 
 // describes a glyph
 // GlyphInfo and TextInfo are used for text centering and word-wrapping operations
-typedef struct glyph_info {
+typedef struct {
     unsigned symbol;
     unsigned skip;              // skip glyph when layouting text
-    ASS_Font *font;
-    int face_index;
-    int glyph_index;
-    double font_size;
-    ASS_Drawing *drawing;
-    FT_Outline *outline;
-    FT_Outline *border;
+    FT_Glyph glyph;
+    FT_Glyph outline_glyph;
     Bitmap *bm;                 // glyph bitmap
     Bitmap *bm_o;               // outline bitmap
     Bitmap *bm_s;               // shadow bitmap
     FT_BBox bbox;
     FT_Vector pos;
-    FT_Vector offset;
     char linebreak;             // the first (leading) glyph of some line ?
     uint32_t c[4];              // colors
     FT_Vector advance;          // 26.6
-    FT_Vector cluster_advance;
     Effect effect_type;
     int effect_timing;          // time duration of current karaoke word
     // after process_karaoke_effects: distance in pixels from the glyph origin.
@@ -132,24 +121,12 @@
     double shadow_y;
     double frx, fry, frz;       // rotation
     double fax, fay;            // text shearing
-    double scale_x, scale_y;
-    double border_x, border_y;
-    unsigned italic;
-    unsigned bold;
-    int flags;
 
-    int bm_run_id;
-    int shape_run_id;
-
     BitmapHashKey hash_key;
-
-    // next glyph in this cluster
-    struct glyph_info *next;
 } GlyphInfo;
 
 typedef struct {
     double asc, desc;
-    int offset, len;
 } LineInfo;
 
 typedef struct {
@@ -170,6 +147,7 @@
     int parsed_tags;
 
     ASS_Font *font;
+    char *font_path;
     double font_size;
     int flags;                  // decoration flags (underline/strike-through)
 
@@ -208,9 +186,6 @@
     int effect_timing;
     int effect_skip_timing;
 
-    // bitmap run id (used for final bitmap rendering)
-    int bm_run_id;
-
     enum {
         SCROLL_LR,              // left-to-right
         SCROLL_RL,
@@ -225,14 +200,13 @@
     unsigned italic;
     int treat_family_as_pattern;
     int wrap_style;
-    int font_encoding;
 } RenderContext;
 
 typedef struct {
-    Cache *font_cache;
-    Cache *outline_cache;
-    Cache *bitmap_cache;
-    Cache *composite_cache;
+    Hashmap *font_cache;
+    Hashmap *glyph_cache;
+    Hashmap *bitmap_cache;
+    Hashmap *composite_cache;
     size_t glyph_max;
     size_t bitmap_max_size;
 } CacheStore;
@@ -244,7 +218,6 @@
     ASS_Settings settings;
     int render_id;
     ASS_SynthPriv *synth_priv;
-    ASS_Shaper *shaper;
 
     ASS_Image *images_root;     // rendering result is stored here
     ASS_Image *prev_images_root;
@@ -292,7 +265,4 @@
 void reset_render_context(ASS_Renderer *render_priv);
 void ass_free_images(ASS_Image *img);
 
-// XXX: this is actually in ass.c, includes should be fixed later on
-void ass_lazy_track_init(ASS_Library *lib, ASS_Track *track);
-
 #endif /* LIBASS_RENDER_H */
Index: libass/ass_render_api.c
===================================================================
--- libass/ass_render_api.c	(revision 34728)
+++ libass/ass_render_api.c	(working copy)
@@ -25,9 +25,12 @@
     ASS_Settings *settings = &priv->settings;
 
     priv->render_id++;
-    ass_cache_empty(priv->cache.outline_cache, 0);
-    ass_cache_empty(priv->cache.bitmap_cache, 0);
-    ass_cache_empty(priv->cache.composite_cache, 0);
+    priv->cache.glyph_cache =
+        ass_glyph_cache_reset(priv->cache.glyph_cache);
+    priv->cache.bitmap_cache =
+        ass_bitmap_cache_reset(priv->cache.bitmap_cache);
+    priv->cache.composite_cache =
+        ass_composite_cache_reset(priv->cache.composite_cache);
     ass_free_images(priv->prev_images_root);
     priv->prev_images_root = 0;
 
@@ -58,17 +61,6 @@
     }
 }
 
-void ass_set_shaper(ASS_Renderer *priv, ASS_ShapingLevel level)
-{
-#ifdef CONFIG_HARFBUZZ
-    // select the complex shaper for illegal values
-    if (level == ASS_SHAPING_SIMPLE || level == ASS_SHAPING_COMPLEX)
-        priv->settings.shaper = level;
-    else
-        priv->settings.shaper = ASS_SHAPING_COMPLEX;
-#endif
-}
-
 void ass_set_margins(ASS_Renderer *priv, int t, int b, int l, int r)
 {
     if (priv->settings.left_margin != l || priv->settings.right_margin != r ||
Index: libass/ass_shaper.c
===================================================================
--- libass/ass_shaper.c	(revision 34728)
+++ libass/ass_shaper.c	(working copy)
@@ -1,757 +0,0 @@
-/*
- * Copyright (C) 2011 Grigori Goronzy <greg@chown.ath.cx>
- *
- * This file is part of libass.
- *
- * Permission to use, copy, modify, and distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- */
-
-#include "config.h"
-
-#ifdef CONFIG_FRIBIDI
-#include <fribidi/fribidi.h>
-#endif
-
-#include "ass_shaper.h"
-#include "ass_render.h"
-#include "ass_font.h"
-#include "ass_parse.h"
-#include "ass_cache.h"
-
-#define MAX_RUNS 50
-
-#ifdef CONFIG_HARFBUZZ
-#include <hb-ft.h>
-enum {
-    VERT = 0,
-    VKNA,
-    KERN
-};
-#define NUM_FEATURES 3
-#endif
-
-struct ass_shaper {
-    ASS_ShapingLevel shaping_level;
-
-    // FriBidi log2vis
-    int n_glyphs;
-#ifdef CONFIG_FRIBIDI
-    FriBidiChar *event_text;
-    FriBidiCharType *ctypes;
-    FriBidiLevel *emblevels;
-#endif
-    FriBidiStrIndex *cmap;
-    FriBidiParType base_direction;
-
-#ifdef CONFIG_HARFBUZZ
-    // OpenType features
-    int n_features;
-    hb_feature_t *features;
-    hb_language_t language;
-
-    // Glyph metrics cache, to speed up shaping
-    Cache *metrics_cache;
-#endif
-};
-
-#ifdef CONFIG_HARFBUZZ
-struct ass_shaper_metrics_data {
-    Cache *metrics_cache;
-    GlyphMetricsHashKey hash_key;
-    int vertical;
-};
-
-struct ass_shaper_font_data {
-    hb_font_t *fonts[ASS_FONT_MAX_FACES];
-    hb_font_funcs_t *font_funcs[ASS_FONT_MAX_FACES];
-    struct ass_shaper_metrics_data *metrics_data[ASS_FONT_MAX_FACES];
-};
-#endif
-
-/**
- * \brief Print version information
- */
-void ass_shaper_info(ASS_Library *lib)
-{
-    ass_msg(lib, MSGL_V, "Shaper:"
-#ifdef CONFIG_FRIBIDI
-            " FriBidi " FRIBIDI_VERSION " (SIMPLE)"
-#endif
-#ifdef CONFIG_HARFBUZZ
-            " HarfBuzz-ng %s (COMPLEX)", hb_version_string()
-#endif
-           );
-}
-
-/**
- * \brief grow arrays, if needed
- * \param new_size requested size
- */
-static void check_allocations(ASS_Shaper *shaper, size_t new_size)
-{
-    if (new_size > shaper->n_glyphs) {
-#ifdef CONFIG_FRIBIDI
-        shaper->event_text = realloc(shaper->event_text, sizeof(FriBidiChar) * new_size);
-        shaper->ctypes     = realloc(shaper->ctypes, sizeof(FriBidiCharType) * new_size);
-        shaper->emblevels  = realloc(shaper->emblevels, sizeof(FriBidiLevel) * new_size);
-#endif
-        shaper->cmap       = realloc(shaper->cmap, sizeof(FriBidiStrIndex) * new_size);
-    }
-}
-
-/**
- * \brief Free shaper and related data
- */
-void ass_shaper_free(ASS_Shaper *shaper)
-{
-#ifdef CONFIG_HARFBUZZ
-    ass_cache_done(shaper->metrics_cache);
-    free(shaper->features);
-#endif
-#ifdef CONFIG_FRIBIDI
-    free(shaper->event_text);
-    free(shaper->ctypes);
-    free(shaper->emblevels);
-#endif
-    free(shaper->cmap);
-    free(shaper);
-}
-
-void ass_shaper_font_data_free(ASS_ShaperFontData *priv)
-{
-#ifdef CONFIG_HARFBUZZ
-    int i;
-    for (i = 0; i < ASS_FONT_MAX_FACES; i++)
-        if (priv->fonts[i]) {
-            free(priv->metrics_data[i]);
-            hb_font_destroy(priv->fonts[i]);
-            hb_font_funcs_destroy(priv->font_funcs[i]);
-        }
-    free(priv);
-#endif
-}
-
-#ifdef CONFIG_HARFBUZZ
-/**
- * \brief set up the HarfBuzz OpenType feature list with some
- * standard features.
- */
-static void init_features(ASS_Shaper *shaper)
-{
-    shaper->features = calloc(sizeof(hb_feature_t), NUM_FEATURES);
-
-    shaper->n_features = NUM_FEATURES;
-    shaper->features[VERT].tag = HB_TAG('v', 'e', 'r', 't');
-    shaper->features[VERT].end = INT_MAX;
-    shaper->features[VKNA].tag = HB_TAG('v', 'k', 'n', 'a');
-    shaper->features[VKNA].end = INT_MAX;
-    shaper->features[KERN].tag = HB_TAG('k', 'e', 'r', 'n');
-    shaper->features[KERN].end = INT_MAX;
-}
-
-/**
- * \brief Set features depending on properties of the run
- */
-static void set_run_features(ASS_Shaper *shaper, GlyphInfo *info)
-{
-        // enable vertical substitutions for @font runs
-        if (info->font->desc.vertical)
-            shaper->features[VERT].value = shaper->features[VKNA].value = 1;
-        else
-            shaper->features[VERT].value = shaper->features[VKNA].value = 0;
-}
-
-/**
- * \brief Update HarfBuzz's idea of font metrics
- * \param hb_font HarfBuzz font
- * \param face associated FreeType font face
- */
-static void update_hb_size(hb_font_t *hb_font, FT_Face face)
-{
-    hb_font_set_scale (hb_font,
-            ((uint64_t) face->size->metrics.x_scale * (uint64_t) face->units_per_EM) >> 16,
-            ((uint64_t) face->size->metrics.y_scale * (uint64_t) face->units_per_EM) >> 16);
-    hb_font_set_ppem (hb_font, face->size->metrics.x_ppem,
-            face->size->metrics.y_ppem);
-}
-
-
-/*
- * Cached glyph metrics getters follow
- *
- * These functions replace HarfBuzz' standard FreeType font functions
- * and provide cached access to essential glyph metrics. This usually
- * speeds up shaping a lot. It also allows us to use custom load flags.
- *
- */
-
-GlyphMetricsHashValue *
-get_cached_metrics(struct ass_shaper_metrics_data *metrics, FT_Face face,
-                   hb_codepoint_t glyph)
-{
-    GlyphMetricsHashValue *val;
-
-    metrics->hash_key.glyph_index = glyph;
-    val = ass_cache_get(metrics->metrics_cache, &metrics->hash_key);
-
-    if (!val) {
-        int load_flags = FT_LOAD_DEFAULT | FT_LOAD_IGNORE_GLOBAL_ADVANCE_WIDTH
-            | FT_LOAD_IGNORE_TRANSFORM;
-        GlyphMetricsHashValue new_val;
-
-        if (FT_Load_Glyph(face, glyph, load_flags))
-            return NULL;
-
-        memcpy(&new_val.metrics, &face->glyph->metrics, sizeof(FT_Glyph_Metrics));
-        val = ass_cache_put(metrics->metrics_cache, &metrics->hash_key, &new_val);
-    }
-
-    return val;
-}
-
-static hb_bool_t
-get_glyph(hb_font_t *font, void *font_data, hb_codepoint_t unicode,
-          hb_codepoint_t variation, hb_codepoint_t *glyph, void *user_data)
-{
-    FT_Face face = font_data;
-
-    if (variation)
-        *glyph = FT_Face_GetCharVariantIndex(face, unicode, variation);
-    else
-        *glyph = FT_Get_Char_Index(face, unicode);
-
-    return *glyph != 0;
-}
-
-static hb_position_t
-cached_h_advance(hb_font_t *font, void *font_data, hb_codepoint_t glyph,
-                 void *user_data)
-{
-    FT_Face face = font_data;
-    struct ass_shaper_metrics_data *metrics_priv = user_data;
-    GlyphMetricsHashValue *metrics = get_cached_metrics(metrics_priv, face, glyph);
-
-    if (!metrics)
-        return 0;
-
-    if (metrics_priv->vertical && glyph > VERTICAL_LOWER_BOUND)
-        return metrics->metrics.vertAdvance;
-
-    return metrics->metrics.horiAdvance;
-}
-
-static hb_position_t
-cached_v_advance(hb_font_t *font, void *font_data, hb_codepoint_t glyph,
-                 void *user_data)
-{
-    FT_Face face = font_data;
-    struct ass_shaper_metrics_data *metrics_priv = user_data;
-    GlyphMetricsHashValue *metrics = get_cached_metrics(metrics_priv, face, glyph);
-
-    if (!metrics)
-        return 0;
-
-    return metrics->metrics.vertAdvance;
-
-}
-
-static hb_bool_t
-cached_h_origin(hb_font_t *font, void *font_data, hb_codepoint_t glyph,
-                hb_position_t *x, hb_position_t *y, void *user_data)
-{
-    return 1;
-}
-
-static hb_bool_t
-cached_v_origin(hb_font_t *font, void *font_data, hb_codepoint_t glyph,
-                hb_position_t *x, hb_position_t *y, void *user_data)
-{
-    FT_Face face = font_data;
-    struct ass_shaper_metrics_data *metrics_priv = user_data;
-    GlyphMetricsHashValue *metrics = get_cached_metrics(metrics_priv, face, glyph);
-
-    if (!metrics)
-        return 0;
-
-    *x = metrics->metrics.horiBearingX - metrics->metrics.vertBearingX;
-    *y = metrics->metrics.horiBearingY - (-metrics->metrics.vertBearingY);
-
-    return 1;
-}
-
-static hb_position_t
-get_h_kerning(hb_font_t *font, void *font_data, hb_codepoint_t first,
-                 hb_codepoint_t second, void *user_data)
-{
-    FT_Face face = font_data;
-    FT_Vector kern;
-
-    if (FT_Get_Kerning (face, first, second, FT_KERNING_DEFAULT, &kern))
-        return 0;
-
-    return kern.x;
-}
-
-static hb_position_t
-get_v_kerning(hb_font_t *font, void *font_data, hb_codepoint_t first,
-                 hb_codepoint_t second, void *user_data)
-{
-    return 0;
-}
-
-static hb_bool_t
-cached_extents(hb_font_t *font, void *font_data, hb_codepoint_t glyph,
-               hb_glyph_extents_t *extents, void *user_data)
-{
-    FT_Face face = font_data;
-    struct ass_shaper_metrics_data *metrics_priv = user_data;
-    GlyphMetricsHashValue *metrics = get_cached_metrics(metrics_priv, face, glyph);
-
-    if (!metrics)
-        return 0;
-
-    extents->x_bearing = metrics->metrics.horiBearingX;
-    extents->y_bearing = metrics->metrics.horiBearingY;
-    extents->width     = metrics->metrics.width;
-    extents->height    = metrics->metrics.height;
-
-    return 1;
-}
-
-static hb_bool_t
-get_contour_point(hb_font_t *font, void *font_data, hb_codepoint_t glyph,
-                     unsigned int point_index, hb_position_t *x,
-                     hb_position_t *y, void *user_data)
-{
-    FT_Face face = font_data;
-    int load_flags = FT_LOAD_DEFAULT | FT_LOAD_IGNORE_GLOBAL_ADVANCE_WIDTH
-        | FT_LOAD_IGNORE_TRANSFORM;
-
-    if (FT_Load_Glyph(face, glyph, load_flags))
-        return 0;
-
-    if (point_index >= (unsigned)face->glyph->outline.n_points)
-        return 0;
-
-    *x = face->glyph->outline.points[point_index].x;
-    *y = face->glyph->outline.points[point_index].y;
-
-    return 1;
-}
-
-/**
- * \brief Retrieve HarfBuzz font from cache.
- * Create it from FreeType font, if needed.
- * \param info glyph cluster
- * \return HarfBuzz font
- */
-static hb_font_t *get_hb_font(ASS_Shaper *shaper, GlyphInfo *info)
-{
-    ASS_Font *font = info->font;
-    hb_font_t **hb_fonts;
-
-    if (!font->shaper_priv)
-        font->shaper_priv = calloc(sizeof(ASS_ShaperFontData), 1);
-
-
-    hb_fonts = font->shaper_priv->fonts;
-    if (!hb_fonts[info->face_index]) {
-        hb_fonts[info->face_index] =
-            hb_ft_font_create(font->faces[info->face_index], NULL);
-
-        // set up cached metrics access
-        font->shaper_priv->metrics_data[info->face_index] =
-            calloc(sizeof(struct ass_shaper_metrics_data), 1);
-        struct ass_shaper_metrics_data *metrics =
-            font->shaper_priv->metrics_data[info->face_index];
-        metrics->metrics_cache = shaper->metrics_cache;
-        metrics->vertical = info->font->desc.vertical;
-
-        hb_font_funcs_t *funcs = hb_font_funcs_create();
-        font->shaper_priv->font_funcs[info->face_index] = funcs;
-        hb_font_funcs_set_glyph_func(funcs, get_glyph,
-                metrics, NULL);
-        hb_font_funcs_set_glyph_h_advance_func(funcs, cached_h_advance,
-                metrics, NULL);
-        hb_font_funcs_set_glyph_v_advance_func(funcs, cached_v_advance,
-                metrics, NULL);
-        hb_font_funcs_set_glyph_h_origin_func(funcs, cached_h_origin,
-                metrics, NULL);
-        hb_font_funcs_set_glyph_v_origin_func(funcs, cached_v_origin,
-                metrics, NULL);
-        hb_font_funcs_set_glyph_h_kerning_func(funcs, get_h_kerning,
-                metrics, NULL);
-        hb_font_funcs_set_glyph_v_kerning_func(funcs, get_v_kerning,
-                metrics, NULL);
-        hb_font_funcs_set_glyph_extents_func(funcs, cached_extents,
-                metrics, NULL);
-        hb_font_funcs_set_glyph_contour_point_func(funcs, get_contour_point,
-                metrics, NULL);
-        hb_font_set_funcs(hb_fonts[info->face_index], funcs,
-                font->faces[info->face_index], NULL);
-    }
-
-    ass_face_set_size(font->faces[info->face_index], info->font_size);
-    update_hb_size(hb_fonts[info->face_index], font->faces[info->face_index]);
-
-    // update hash key for cached metrics
-    struct ass_shaper_metrics_data *metrics =
-        font->shaper_priv->metrics_data[info->face_index];
-    metrics->hash_key.font = info->font;
-    metrics->hash_key.face_index = info->face_index;
-    metrics->hash_key.size = info->font_size;
-    metrics->hash_key.scale_x = double_to_d6(info->scale_x);
-    metrics->hash_key.scale_y = double_to_d6(info->scale_y);
-
-    return hb_fonts[info->face_index];
-}
-
-/**
- * \brief Shape event text with HarfBuzz. Full OpenType shaping.
- * \param glyphs glyph clusters
- * \param len number of clusters
- */
-static void shape_harfbuzz(ASS_Shaper *shaper, GlyphInfo *glyphs, size_t len)
-{
-    int i, j;
-    int run = 0;
-    struct {
-        int offset;
-        int end;
-        hb_buffer_t *buf;
-        hb_font_t *font;
-    } runs[MAX_RUNS];
-
-
-    for (i = 0; i < len && run < MAX_RUNS; i++, run++) {
-        // get length and level of the current run
-        int k = i;
-        int level = glyphs[i].shape_run_id;
-        int direction = shaper->emblevels[k] % 2;
-        while (i < (len - 1) && level == glyphs[i+1].shape_run_id)
-            i++;
-        runs[run].offset = k;
-        runs[run].end    = i;
-        runs[run].buf    = hb_buffer_create();
-        runs[run].font   = get_hb_font(shaper, glyphs + k);
-        set_run_features(shaper, glyphs + k);
-        hb_buffer_pre_allocate(runs[run].buf, i - k + 1);
-        hb_buffer_set_direction(runs[run].buf, direction ? HB_DIRECTION_RTL :
-                HB_DIRECTION_LTR);
-        hb_buffer_set_language(runs[run].buf, shaper->language);
-        hb_buffer_add_utf32(runs[run].buf, shaper->event_text + k, i - k + 1,
-                0, i - k + 1);
-        hb_shape(runs[run].font, runs[run].buf, shaper->features,
-                shaper->n_features);
-    }
-
-    // Initialize: skip all glyphs, this is undone later as needed
-    for (i = 0; i < len; i++)
-        glyphs[i].skip = 1;
-
-    // Update glyph indexes, positions and advances from the shaped runs
-    for (i = 0; i < run; i++) {
-        int num_glyphs = hb_buffer_get_length(runs[i].buf);
-        hb_glyph_info_t *glyph_info = hb_buffer_get_glyph_infos(runs[i].buf, NULL);
-        hb_glyph_position_t *pos    = hb_buffer_get_glyph_positions(runs[i].buf, NULL);
-
-        for (j = 0; j < num_glyphs; j++) {
-            int idx = glyph_info[j].cluster + runs[i].offset;
-            GlyphInfo *info = glyphs + idx;
-            GlyphInfo *root = info;
-
-            // if we have more than one glyph per cluster, allocate a new one
-            // and attach to the root glyph
-            if (info->skip == 0) {
-                while (info->next)
-                    info = info->next;
-                info->next = malloc(sizeof(GlyphInfo));
-                memcpy(info->next, info, sizeof(GlyphInfo));
-                info = info->next;
-                info->next = NULL;
-            }
-
-            // set position and advance
-            info->skip = 0;
-            info->glyph_index = glyph_info[j].codepoint;
-            info->offset.x    = pos[j].x_offset * info->scale_x;
-            info->offset.y    = -pos[j].y_offset * info->scale_y;
-            info->advance.x   = pos[j].x_advance * info->scale_x;
-            info->advance.y   = -pos[j].y_advance * info->scale_y;
-
-            // accumulate advance in the root glyph
-            root->cluster_advance.x += info->advance.x;
-            root->cluster_advance.y += info->advance.y;
-        }
-    }
-
-    // Free runs and associated data
-    for (i = 0; i < run; i++) {
-        hb_buffer_destroy(runs[i].buf);
-    }
-
-}
-#endif
-
-#ifdef CONFIG_FRIBIDI
-/**
- * \brief Shape event text with FriBidi. Does mirroring and simple
- * Arabic shaping.
- * \param len number of clusters
- */
-static void shape_fribidi(ASS_Shaper *shaper, GlyphInfo *glyphs, size_t len)
-{
-    int i;
-    FriBidiJoiningType *joins = calloc(sizeof(*joins), len);
-
-    // shape on codepoint level
-    fribidi_get_joining_types(shaper->event_text, len, joins);
-    fribidi_join_arabic(shaper->ctypes, len, shaper->emblevels, joins);
-    fribidi_shape(FRIBIDI_FLAGS_DEFAULT | FRIBIDI_FLAGS_ARABIC,
-            shaper->emblevels, len, joins, shaper->event_text);
-
-    // update indexes
-    for (i = 0; i < len; i++) {
-        GlyphInfo *info = glyphs + i;
-        FT_Face face = info->font->faces[info->face_index];
-        info->symbol = shaper->event_text[i];
-        info->glyph_index = FT_Get_Char_Index(face, shaper->event_text[i]);
-    }
-
-    free(joins);
-}
-#endif
-
-/**
- * \brief Toggle kerning for HarfBuzz shaping.
- * NOTE: currently only works with OpenType fonts, the TrueType fallback *always*
- * kerns. It's a bug in HarfBuzz.
- */
-void ass_shaper_set_kerning(ASS_Shaper *shaper, int kern)
-{
-#ifdef CONFIG_HARFBUZZ
-    shaper->features[KERN].value = !!kern;
-#endif
-}
-
-/**
- * \brief Find shape runs according to the event's selected fonts
- */
-void ass_shaper_find_runs(ASS_Shaper *shaper, ASS_Renderer *render_priv,
-                          GlyphInfo *glyphs, size_t len)
-{
-    int i;
-    int shape_run = 0;
-
-    for (i = 0; i < len; i++) {
-        GlyphInfo *last = glyphs + i - 1;
-        GlyphInfo *info = glyphs + i;
-        // skip drawings
-        if (info->symbol == 0xfffc)
-            continue;
-        // set size and get glyph index
-        ass_font_get_index(render_priv->fontconfig_priv, info->font,
-                info->symbol, &info->face_index, &info->glyph_index);
-        // shape runs share the same font face and size
-        if (i > 0 && (last->font != info->font ||
-                    last->font_size != info->font_size ||
-                    last->face_index != info->face_index))
-            shape_run++;
-        info->shape_run_id = shape_run;
-    }
-
-}
-
-/**
- * \brief Set base direction (paragraph direction) of the text.
- * \param dir base direction
- */
-void ass_shaper_set_base_direction(ASS_Shaper *shaper, FriBidiParType dir)
-{
-    shaper->base_direction = dir;
-}
-
-/**
- * \brief Set language hint. Some languages have specific character variants,
- * like Serbian Cyrillic.
- * \param lang ISO 639-1 two-letter language code
- */
-void ass_shaper_set_language(ASS_Shaper *shaper, const char *code)
-{
-#ifdef CONFIG_HARFBUZZ
-    shaper->language = hb_language_from_string(code, -1);
-#endif
-}
-
-/**
- * Set shaping level. Essentially switches between FriBidi and HarfBuzz.
- */
-void ass_shaper_set_level(ASS_Shaper *shaper, ASS_ShapingLevel level)
-{
-    shaper->shaping_level = level;
-}
-
-/**
- * \brief Shape an event's text. Calculates directional runs and shapes them.
- * \param text_info event's text
- */
-void ass_shaper_shape(ASS_Shaper *shaper, TextInfo *text_info)
-{
-#ifndef CONFIG_FRIBIDI
-    check_allocations(shaper, text_info->length);
-#else
-    int i, last_break;
-    FriBidiParType dir;
-    GlyphInfo *glyphs = text_info->glyphs;
-
-    check_allocations(shaper, text_info->length);
-
-    // Get bidi character types and embedding levels
-    last_break = 0;
-    for (i = 0; i < text_info->length; i++) {
-        shaper->event_text[i] = glyphs[i].symbol;
-        // embedding levels should be calculated paragraph by paragraph
-        if (glyphs[i].symbol == '\n' || i == text_info->length - 1) {
-            dir = shaper->base_direction;
-            fribidi_get_bidi_types(shaper->event_text + last_break,
-                    i - last_break + 1, shaper->ctypes + last_break);
-            fribidi_get_par_embedding_levels(shaper->ctypes + last_break,
-                    i - last_break + 1, &dir, shaper->emblevels + last_break);
-            last_break = i + 1;
-        }
-    }
-
-    // add embedding levels to shape runs for final runs
-    for (i = 0; i < text_info->length; i++) {
-        glyphs[i].shape_run_id += shaper->emblevels[i];
-    }
-
-#ifdef CONFIG_HARFBUZZ
-    switch (shaper->shaping_level) {
-    case ASS_SHAPING_SIMPLE:
-        shape_fribidi(shaper, glyphs, text_info->length);
-        break;
-    case ASS_SHAPING_COMPLEX:
-        shape_harfbuzz(shaper, glyphs, text_info->length);
-        break;
-    }
-#else
-        shape_fribidi(shaper, glyphs, text_info->length);
-#endif
-
-
-    // clean up
-    for (i = 0; i < text_info->length; i++) {
-        // Skip direction override control characters
-        // NOTE: Behdad said HarfBuzz is supposed to remove these, but this hasn't
-        // been implemented yet
-        if (glyphs[i].symbol <= 0x202F && glyphs[i].symbol >= 0x202a) {
-            glyphs[i].symbol = 0;
-            glyphs[i].skip++;
-        }
-    }
-#endif
-}
-
-/**
- * \brief Create a new shaper instance and preallocate data structures
- * \param prealloc preallocation size
- */
-ASS_Shaper *ass_shaper_new(size_t prealloc)
-{
-    ASS_Shaper *shaper = calloc(sizeof(*shaper), 1);
-
-#ifdef CONFIG_FRIBIDI
-    shaper->base_direction = FRIBIDI_PAR_ON;
-#endif
-    check_allocations(shaper, prealloc);
-
-#ifdef CONFIG_HARFBUZZ
-    init_features(shaper);
-    shaper->metrics_cache = ass_glyph_metrics_cache_create();
-#endif
-
-    return shaper;
-}
-
-
-/**
- * \brief clean up additional data temporarily needed for shaping and
- * (e.g. additional glyphs allocated)
- */
-void ass_shaper_cleanup(ASS_Shaper *shaper, TextInfo *text_info)
-{
-    int i;
-
-    for (i = 0; i < text_info->length; i++) {
-        GlyphInfo *info = text_info->glyphs + i;
-        info = info->next;
-        while (info) {
-            GlyphInfo *next = info->next;
-            free(info);
-            info = next;
-        }
-    }
-}
-
-/**
- * \brief Calculate reorder map to render glyphs in visual order
- */
-FriBidiStrIndex *ass_shaper_reorder(ASS_Shaper *shaper, TextInfo *text_info)
-{
-    int i;
-
-    // Initialize reorder map
-    for (i = 0; i < text_info->length; i++)
-        shaper->cmap[i] = i;
-
-#ifdef CONFIG_FRIBIDI
-    // Create reorder map line-by-line
-    for (i = 0; i < text_info->n_lines; i++) {
-        LineInfo *line = text_info->lines + i;
-        int level;
-        FriBidiParType dir = FRIBIDI_PAR_ON;
-
-        level = fribidi_reorder_line(0,
-                shaper->ctypes + line->offset, line->len, 0, dir,
-                shaper->emblevels + line->offset, NULL,
-                shaper->cmap + line->offset);
-    }
-#endif
-
-    return shaper->cmap;
-}
-
-/**
- * \brief Resolve a Windows font encoding number to a suitable
- * base direction. 177 and 178 are Hebrew and Arabic respectively, and
- * they map to RTL. 1 is autodetection and is mapped to just that.
- * Everything else is mapped to LTR.
- * \param enc Windows font encoding
- */
-FriBidiParType resolve_base_direction(int enc)
-{
-#ifdef CONFIG_FRIBIDI
-    switch (enc) {
-        case 1:
-            return FRIBIDI_PAR_ON;
-        case 177:
-        case 178:
-            return FRIBIDI_PAR_RTL;
-        default:
-            return FRIBIDI_PAR_LTR;
-    }
-#else
-    return 0;
-#endif
-}
Index: libass/ass_shaper.h
===================================================================
--- libass/ass_shaper.h	(revision 34728)
+++ libass/ass_shaper.h	(working copy)
@@ -1,48 +0,0 @@
-/*
- * Copyright (C) 2011 Grigori Goronzy <greg@chown.ath.cx>
- *
- * This file is part of libass.
- *
- * Permission to use, copy, modify, and distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- */
-
-#ifndef LIBASS_SHAPER_H
-#define LIBASS_SHAPER_H
-
-#include "config.h"
-
-#ifdef CONFIG_FRIBIDI
-#include <fribidi/fribidi.h>
-#else
-typedef int FriBidiParType;
-typedef int FriBidiStrIndex;
-#endif
-#include "ass_render.h"
-
-void ass_shaper_info(ASS_Library *lib);
-ASS_Shaper *ass_shaper_new(size_t prealloc);
-void ass_shaper_free(ASS_Shaper *shaper);
-void ass_shaper_set_kerning(ASS_Shaper *shaper, int kern);
-void ass_shaper_find_runs(ASS_Shaper *shaper, ASS_Renderer *render_priv,
-                          GlyphInfo *glyphs, size_t len);
-void ass_shaper_set_base_direction(ASS_Shaper *shaper, FriBidiParType dir);
-void ass_shaper_set_language(ASS_Shaper *shaper, const char *code);
-void ass_shaper_set_level(ASS_Shaper *shaper, ASS_ShapingLevel level);
-void ass_shaper_shape(ASS_Shaper *shaper, TextInfo *text_info);
-void ass_shaper_cleanup(ASS_Shaper *shaper, TextInfo *text_info);
-FriBidiStrIndex *ass_shaper_reorder(ASS_Shaper *shaper, TextInfo *text_info);
-FriBidiParType resolve_base_direction(int font_encoding);
-
-void ass_shaper_font_data_free(ASS_ShaperFontData *priv);
-
-#endif
Index: libass/ass_types.h
===================================================================
--- libass/ass_types.h	(revision 34728)
+++ libass/ass_types.h	(working copy)
@@ -112,7 +112,6 @@
     int WrapStyle;
     int ScaledBorderAndShadow;
     int Kerning;
-    char *Language;
 
     int default_style;      // index of default style
     char *name;             // file name in case of external subs, 0 for streams
Index: libvo/sdl_common.c
===================================================================
--- libvo/sdl_common.c	(revision 34728)
+++ libvo/sdl_common.c	(working copy)
@@ -63,7 +63,7 @@
         if (WinID > 0) {
             char envstr[20];
             snprintf(envstr, sizeof(envstr), "0x%"PRIx64, WinID);
-            setenv("SDL_WINDOWID", envstr, 1);
+            putenv("SDL_WINDOWID=1");
         }
         if (SDL_Init(SDL_INIT_VIDEO|SDL_INIT_NOPARACHUTE) < 0)
             return 0;
@@ -125,7 +125,7 @@
     if (geometry_xy_changed) {
         char envstr[20];
         snprintf(envstr, sizeof(envstr), "%i,%i", vo_dx, vo_dy);
-        setenv("SDL_VIDEO_WINDOW_POS", envstr, 1);
+        putenv("SDL_VIDEO_WINDOW_POS=1");
     }
     s = SDL_SetVideoMode(vo_dwidth, vo_dheight, bpp, flags);
     if (!s) {
Index: libvo/vo_sdl.c
===================================================================
--- libvo/vo_sdl.c	(revision 34728)
+++ libvo/vo_sdl.c	(working copy)
@@ -1333,17 +1333,17 @@
     mp_msg(MSGT_VO,MSGL_DBG3, "SDL: Opening Plugin\n");
 
     if(sdl_driver) {
-        setenv("SDL_VIDEODRIVER", sdl_driver, 1);
+        putenv("SDL_VIDEODRIVER=1");
     free(sdl_driver);
     }
 
     /* does the user want SDL to try and force Xv */
-    if(sdl_forcexv)	setenv("SDL_VIDEO_X11_NODIRECTCOLOR", "1", 1);
-    else setenv("SDL_VIDEO_X11_NODIRECTCOLOR", "0", 1);
+    if(sdl_forcexv)	putenv("SDL_VIDEO_X11_NODIRECTCOLOR=1");
+    else putenv("SDL_VIDEO_X11_NODIRECTCOLOR=0");
 
     /* does the user want to disable Xv and use software scaling instead */
-    if(sdl_hwaccel) setenv("SDL_VIDEO_YUV_HWACCEL", "1", 1);
-    else setenv("SDL_VIDEO_YUV_HWACCEL", "0", 1);
+    if(sdl_hwaccel) putenv("SDL_VIDEO_YUV_HWACCEL=1");
+    else putenv("SDL_VIDEO_YUV_HWACCEL=0");
 
     /* default to no fullscreen mode, we'll set this as soon we have the avail. modes */
     priv->fullmode = -2;
Index: Makefile
===================================================================
--- Makefile	(revision 34728)
+++ Makefile	(working copy)
@@ -115,7 +115,6 @@
                                         libass/ass_parse.c \
                                         libass/ass_render.c \
                                         libass/ass_render_api.c \
-                                        libass/ass_shaper.c \
                                         libass/ass_strtod.c \
                                         libass/ass_utils.c \
 
Index: mencoder.c
===================================================================
--- mencoder.c	(revision 34728)
+++ mencoder.c	(working copy)
@@ -139,6 +139,7 @@
 int benchmark=0;
 
 // A-V sync:
+int delay_corrected=1;
 static float default_max_pts_correction=-1;//0.01f;
 static float max_pts_correction=0;//default_max_pts_correction;
 static float c_total=0;
@@ -1539,11 +1540,18 @@
           ((ds_tell(d_audio)-sh_audio->a_in_buffer_len)/sh_audio->audio.dwSampleSize) :
           (d_audio->block_no); // <- used for VBR audio
         a_pts=samples*(float)sh_audio->audio.dwScale/(float)sh_audio->audio.dwRate;
+	delay_corrected=1;
     } else
 #endif
     {
-      // PTS = (last timestamp) + (bytes after last timestamp)/(bytes per sec)
-      a_pts=calc_a_pts(sh_audio, d_audio);
+        // PTS = (last timestamp) + (bytes after last timestamp)/(bytes per sec)
+        #ifdef CONFIG_DVDREAD
+            a_pts=d_audio->pts;
+            if(!delay_corrected) if(a_pts) delay_corrected=1;
+            a_pts+=(ds_tell_pts(d_audio)-sh_audio->a_in_buffer_len)/(float)sh_audio->i_bps;
+        #else
+            a_pts=calc_a_pts(sh_audio, d_audio);
+        #endif
     }
     v_pts=sh_video ? sh_video->pts : d_video->pts;
     // av = compensated (with out buffering delay) A-V diff
Index: mp_msg.c
===================================================================
--- mp_msg.c	(revision 34728)
+++ mp_msg.c	(working copy)
@@ -34,6 +34,26 @@
 /* maximum message length of mp_msg */
 #define MSGSIZE_MAX 3072
 
+#ifdef _WIN32
+#define WIN32_LEAN_AND_MEAN
+#include <windows.h>
+#include <io.h>
+#define hSTDOUT GetStdHandle(STD_OUTPUT_HANDLE)
+static short stdoutAttrs = 0;
+static const unsigned char ansi2win32[10] = {
+    0,
+    FOREGROUND_RED,
+    FOREGROUND_GREEN,
+    FOREGROUND_GREEN | FOREGROUND_RED,
+    FOREGROUND_BLUE,
+    FOREGROUND_BLUE  | FOREGROUND_RED,
+    FOREGROUND_BLUE  | FOREGROUND_GREEN,
+    FOREGROUND_BLUE  | FOREGROUND_GREEN | FOREGROUND_RED,
+    FOREGROUND_BLUE  | FOREGROUND_GREEN | FOREGROUND_RED,
+    FOREGROUND_BLUE  | FOREGROUND_GREEN | FOREGROUND_RED
+};
+#endif
+
 int mp_msg_levels[MSGT_MAX]; // verbose level of this module. initialized to -2
 int mp_msg_level_all = MSGL_STATUS;
 int verbose = 0;
@@ -77,6 +97,15 @@
 }
 
 void mp_msg_init(void){
+#ifdef _WIN32
+    CONSOLE_SCREEN_BUFFER_INFO cinfo;
+    long cmode = 0;
+    GetConsoleMode(hSTDOUT, &cmode);
+    cmode |= (ENABLE_PROCESSED_OUTPUT | ENABLE_WRAP_AT_EOL_OUTPUT);
+    SetConsoleMode(hSTDOUT, cmode);
+    GetConsoleScreenBufferInfo(hSTDOUT, &cinfo);
+    stdoutAttrs = cinfo.wAttributes;
+#endif
     int i;
     char *env = getenv("MPLAYER_VERBOSE");
     if (env)
@@ -111,7 +140,11 @@
     }
 #endif
     if (mp_msg_color)
+#ifdef _WIN32
+        SetConsoleTextAttribute(hSTDOUT, ansi2win32[c] | FOREGROUND_INTENSITY);
+#else
         fprintf(stream, "\033[%d;3%dm", c >> 3, c & 7);
+#endif
 }
 
 static void print_msg_module(FILE* stream, int mod)
@@ -168,11 +201,19 @@
 
     if (!mp_msg_module)
         return;
+#ifdef _WIN32
     if (mp_msg_color)
+        SetConsoleTextAttribute(hSTDOUT, ansi2win32[c2&7] | FOREGROUND_INTENSITY);
+    fprintf(stream, "%9s", module_text[mod]);
+    if (mp_msg_color)
+        SetConsoleTextAttribute(hSTDOUT, stdoutAttrs);
+#else
+    if (mp_msg_color)
         fprintf(stream, "\033[%d;3%dm", c2 >> 3, c2 & 7);
     fprintf(stream, "%9s", module_text[mod]);
     if (mp_msg_color)
         fprintf(stream, "\033[0;37m");
+#endif
     fprintf(stream, ": ");
 }
 
@@ -240,6 +281,10 @@
 
     fprintf(stream, "%s", tmp);
     if (mp_msg_color)
+#ifdef _WIN32
+        SetConsoleTextAttribute(hSTDOUT, stdoutAttrs);
+#else
         fprintf(stream, "\033[0m");
+#endif
     fflush(stream);
 }
Index: mpcommon.c
===================================================================
--- mpcommon.c	(revision 34728)
+++ mpcommon.c	(working copy)
@@ -538,40 +538,46 @@
 /// Returns a_pts
 double calc_a_pts(sh_audio_t *sh_audio, demux_stream_t *d_audio)
 {
-    double a_pts;
-    if(!sh_audio || !d_audio)
-        return MP_NOPTS_VALUE;
-    // first calculate the end pts of audio that has been output by decoder
-    a_pts = sh_audio->pts;
-    // If we cannot get any useful information at all from the demuxer layer
-    // just count the decoded bytes. This is still better than constantly
-    // resetting to 0.
-    if (sh_audio->pts_bytes && a_pts == MP_NOPTS_VALUE &&
-        !d_audio->pts && !sh_audio->i_bps)
-        a_pts = 0;
-    if (a_pts != MP_NOPTS_VALUE)
-        // Good, decoder supports new way of calculating audio pts.
-        // sh_audio->pts is the timestamp of the latest input packet with
-        // known pts that the decoder has decoded. sh_audio->pts_bytes is
-        // the amount of bytes the decoder has written after that timestamp.
-        a_pts += sh_audio->pts_bytes / (double) sh_audio->o_bps;
-    else {
-        // Decoder doesn't support new way of calculating pts (or we're
-        // being called before it has decoded anything with known timestamp).
-        // Use the old method of audio pts calculation: take the timestamp
-        // of last packet with known pts the decoder has read data from,
-        // and add amount of bytes read after the beginning of that packet
-        // divided by input bps. This will be inaccurate if the input/output
-        // ratio is not constant for every audio packet or if it is constant
-        // but not accurately known in sh_audio->i_bps.
+    #ifdef CONFIG_DVDREAD
+        float a_pts = 0.;
+        if (sh_audio)
+            a_pts = d_audio->pts + (ds_tell_pts(d_audio) - sh_audio->a_in_buffer_len)/(float)sh_audio->i_bps;
+    #else
+        double a_pts;
+        if(!sh_audio || !d_audio)
+            return MP_NOPTS_VALUE;
+        // first calculate the end pts of audio that has been output by decoder
+        a_pts = sh_audio->pts;
+        // If we cannot get any useful information at all from the demuxer layer
+        // just count the decoded bytes. This is still better than constantly
+        // resetting to 0.
+        if (sh_audio->pts_bytes && a_pts == MP_NOPTS_VALUE &&
+            !d_audio->pts && !sh_audio->i_bps)
+            a_pts = 0;
+        if (a_pts != MP_NOPTS_VALUE)
+            // Good, decoder supports new way of calculating audio pts.
+            // sh_audio->pts is the timestamp of the latest input packet with
+            // known pts that the decoder has decoded. sh_audio->pts_bytes is
+            // the amount of bytes the decoder has written after that timestamp.
+            a_pts += sh_audio->pts_bytes / (double) sh_audio->o_bps;
+        else {
+            // Decoder doesn't support new way of calculating pts (or we're
+            // being called before it has decoded anything with known timestamp).
+            // Use the old method of audio pts calculation: take the timestamp
+            // of last packet with known pts the decoder has read data from,
+            // and add amount of bytes read after the beginning of that packet
+            // divided by input bps. This will be inaccurate if the input/output
+            // ratio is not constant for every audio packet or if it is constant
+            // but not accurately known in sh_audio->i_bps.
 
-        a_pts = d_audio->pts;
-        // ds_tell_pts returns bytes read after last timestamp from
-        // demuxing layer, decoder might use sh_audio->a_in_buffer for bytes
-        // it has read but not decoded
-        if (sh_audio->i_bps)
-            a_pts += (ds_tell_pts(d_audio) - sh_audio->a_in_buffer_len) /
-                     (double)sh_audio->i_bps;
-    }
+            a_pts = d_audio->pts;
+            // ds_tell_pts returns bytes read after last timestamp from
+            // demuxing layer, decoder might use sh_audio->a_in_buffer for bytes
+            // it has read but not decoded
+            if (sh_audio->i_bps)
+                a_pts += (ds_tell_pts(d_audio) - sh_audio->a_in_buffer_len) /
+                         (double)sh_audio->i_bps;
+        }
+    #endif
     return a_pts;
 }
Index: mplayer.c
===================================================================
--- mplayer.c	(revision 34728)
+++ mplayer.c	(working copy)
@@ -145,6 +145,12 @@
 float start_volume = -1;
 double start_pts   = MP_NOPTS_VALUE;
 char *heartbeat_cmd;
+
+#ifdef CONFIG_FONTCONFIG
+#include <fontconfig/fontconfig.h>
+extern int FcDebugVal;
+#endif
+
 static int max_framesize;
 
 int noconsolecontrols;
@@ -525,10 +531,6 @@
             (mpctx->sh_video && video_start_pts < start_pts))
             start_pts = video_start_pts;
     }
-    if (start_pts != MP_NOPTS_VALUE)
-        mp_msg(MSGT_IDENTIFY, MSGL_INFO, "ID_START_TIME=%.2f\n", start_pts);
-    else
-        mp_msg(MSGT_IDENTIFY, MSGL_INFO, "ID_START_TIME=unknown\n");
     mp_msg(MSGT_IDENTIFY, MSGL_INFO, "ID_LENGTH=%.2f\n", demuxer_get_time_length(mpctx->demuxer));
     mp_msg(MSGT_IDENTIFY, MSGL_INFO, "ID_SEEKABLE=%d\n",
            mpctx->stream->seek && (!mpctx->demuxer || mpctx->demuxer->seekable));
@@ -3025,7 +3027,15 @@
         gui(GUI_SET_CONTEXT, mpctx);
         gui(GUI_SET_STATE, (void *)(filename ? GUI_PLAY : GUI_STOP));
     }
+#else
+    /* force cache creation here and display fontconfig scan activity */     
+    FcDebugVal = 128;
+#ifdef _WIN32
+    FcConfigEnableHome(FcFalse);
 #endif
+    FcInit();
+    FcDebugVal = 0;
+#endif
 
 // ******************* Now, let's see the per-file stuff ********************
 
Index: osdep/alloc-win.c
===================================================================
--- osdep/alloc-win.c	(revision 0)
+++ osdep/alloc-win.c	(working copy)
@@ -0,0 +1,185 @@
+#define DEFAULT_ALIGNMENT   16
+//#define DEBUG_ALLOC
+
+/*
+  __mingw_aligned_malloc and friends, implemented using Microsoft's public
+  interfaces and with the help of the algorithm description provided
+  by Wu Yongwei: http://sourceforge.net/mailarchive/message.php?msg_id=3847075
+
+  I hereby place this implementation in the public domain.
+               -- Steven G. Johnson (stevenj@alum.mit.edu)
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <stddef.h>             /* ptrdiff_t */
+#include <string.h>             /* memmove */
+
+#include <windows.h>
+
+#ifdef DEBUG_ALLOC
+#undef fprintf
+extern int fprintf (FILE *__stream, const char *__format, ...);
+#define TRACE(...) fprintf(stderr, __VA_ARGS__)
+#else
+#define TRACE(...)
+#endif
+
+#define WILL_WRAP(size, alignment) (size > (0xffffffff - (alignment + sizeof (void *))))
+
+#ifdef HAVE_STDINT_H
+#  include <stdint.h>           /* uintptr_t */
+#else
+#  define uintptr_t size_t
+#endif
+
+#define NOT_POWER_OF_TWO(n) (((n) & ((n) - 1)))
+#define UI(p) ((uintptr_t) (p))
+#define CP(p) ((char *) p)
+
+#define PTR_ALIGN(p0, alignment, offset)                                \
+            ((void *) (((UI(p0) + (alignment + sizeof(void*)) + offset) \
+                        & (~UI(alignment - 1)))                         \
+                       - offset))
+
+/* Pointer must sometimes be aligned; assume sizeof(void*) is a power of two. */
+#define ORIG_PTR(p) (*(((void **) (UI(p) & (~UI(sizeof(void*) - 1)))) - 1))
+
+static void *
+__mingw_aligned_offset_malloc (size_t size, size_t alignment, size_t offset)
+{
+  void *p0, *p;
+
+  if (NOT_POWER_OF_TWO (alignment))
+    {
+      errno = EINVAL;
+      return ((void *) 0);
+    }
+  if ((size == 0) || WILL_WRAP(size, alignment))
+    return ((void *) 0);
+  if (alignment < sizeof (void *))
+    alignment = sizeof (void *);
+
+  /* Including the extra sizeof(void*) is overkill on a 32-bit
+     machine, since malloc is already 8-byte aligned, as long
+     as we enforce alignment >= 8 ...but oh well.  */
+
+  p0 = HeapAlloc (GetProcessHeap(), 0, size + (alignment + sizeof (void *)));
+  if (!p0)
+    return ((void *) 0);
+  p = PTR_ALIGN (p0, alignment, offset);
+  ORIG_PTR (p) = p0;
+  return p;
+}
+
+static void *
+__mingw_aligned_malloc (size_t size, size_t alignment)
+{
+  return __mingw_aligned_offset_malloc (size, alignment, 0);
+}
+
+static void
+__mingw_aligned_free (void *memblock)
+{
+  if (memblock)
+    HeapFree(GetProcessHeap(), 0, ORIG_PTR (memblock));
+}
+
+static void *
+__mingw_aligned_offset_realloc (void *memblock, size_t size,
+                                size_t alignment, size_t offset)
+{
+  void *p0, *p;
+  ptrdiff_t shift;
+
+  if (!memblock)
+    return __mingw_aligned_offset_malloc (size, alignment, offset);
+  if (NOT_POWER_OF_TWO (alignment))
+    goto bad;
+  if ((size == 0) || WILL_WRAP(size, alignment))
+    {
+      __mingw_aligned_free (memblock);
+      return ((void *) 0);
+    }
+  if (alignment < sizeof (void *))
+    alignment = sizeof (void *);
+
+  p0 = ORIG_PTR (memblock);
+  /* It is an error for the alignment to change. */
+  if (memblock != PTR_ALIGN (p0, alignment, offset))
+    goto bad;
+  shift = CP (memblock) - CP (p0);
+
+  p0 = HeapReAlloc(GetProcessHeap(), 0, p0, size + (alignment + sizeof (void *)));
+  if (!p0)
+    return ((void *) 0);
+  p = PTR_ALIGN (p0, alignment, offset);
+
+  /* Relative shift of actual data may be different from before, ugh.  */
+  if (shift != CP (p) - CP (p0))
+    /* ugh, moves more than necessary if size is increased.  */
+    memmove (CP (p), CP (p0) + shift, size);
+
+  ORIG_PTR (p) = p0;
+  return p;
+
+bad:
+  errno = EINVAL;
+  return ((void *) 0);
+}
+
+static void *
+__mingw_aligned_realloc (void *memblock, size_t size, size_t alignment)
+{
+  return __mingw_aligned_offset_realloc (memblock, size, alignment, 0);
+}
+
+/* WRAPPERS */
+
+void *malloc(size_t size)
+{
+    void *p = __mingw_aligned_malloc(size, DEFAULT_ALIGNMENT);
+    TRACE("MALLOC(%d) = %p\n", size, p);
+    return p;
+}
+
+void *memalign(size_t boundary, size_t size)
+{
+    void *p = __mingw_aligned_malloc(size, boundary);
+    TRACE("MEMALIGN(%d, %d) = %p\n", boundary, size, p);
+    return p;
+}
+
+void *calloc(size_t nmemb, size_t size)
+{
+    size_t sz = nmemb * size;
+    char *d = __mingw_aligned_malloc(sz, DEFAULT_ALIGNMENT);
+    memset(d, 0, sz);
+    TRACE("CALLOC(%d, %d) = %p\n", nmemb, size, d);
+    return d;
+}
+
+void *realloc(void *ptr, size_t size)
+{
+    void *p = __mingw_aligned_realloc(ptr, size, DEFAULT_ALIGNMENT);
+    TRACE("REALLOC(%p, %d) = %p\n", ptr, size, p);
+    return p;
+}
+
+void free(void *ptr)
+{
+    TRACE("FREE(%p)\n", ptr);
+    __mingw_aligned_free(ptr);
+}
+
+char *strdup(const char *s)
+{
+    char *d;
+    size_t size = strlen(s) + 1;
+    d = __mingw_aligned_malloc(size, DEFAULT_ALIGNMENT);
+    memcpy(d, s, size - 1);
+    d[size - 1] = 0;
+    TRACE("STRDUP(%p) = %p\n", s, d);
+    return d;
+}
\ No newline at end of file
Index: version.sh
===================================================================
--- version.sh	(revision 34728)
+++ version.sh	(working copy)
@@ -17,9 +17,9 @@
 version=$svn_revision
 fi
 
-NEW_REVISION="#define VERSION \"${version}${extra}\""
+NEW_REVISION="#define VERSION \"SB25\""
 OLD_REVISION=$(head -n 1 version.h 2> /dev/null)
-TITLE='#define MP_TITLE "%s "VERSION" (C) 2000-2012 MPlayer Team\n"'
+TITLE='#define MP_TITLE "%s "VERSION" (C) 2000-2012 MPlayer Team\nCustom build by SubJunk, http://www.spirton.com\n\n"'
 
 # Update version.h only on revision changes to avoid spurious rebuilds
 if test "$NEW_REVISION" != "$OLD_REVISION"; then
